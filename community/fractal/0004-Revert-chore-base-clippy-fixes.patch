From 3ce525b7dd2e18d14f369b6d7313d34c3b361caa Mon Sep 17 00:00:00 2001
From: Matthias Ahouansou <matthias@ahouansou.cz>
Date: Tue, 12 Aug 2025 00:29:19 +0200
Subject: [PATCH 4/5] Revert "chore(base): clippy fixes"

This reverts commit 35a8528712520dc2a48b7d02f24a8bee7877b2ba.
---
 crates/matrix-sdk-base/src/client.rs          | 29 +++++++-------
 crates/matrix-sdk-base/src/latest_event.rs    | 28 +++++++-------
 crates/matrix-sdk-base/src/read_receipts.rs   | 38 +++++++++----------
 .../account_data/global.rs                    |  8 ++--
 .../response_processors/e2ee/tracked_users.rs | 35 ++++++++---------
 .../response_processors/room/msc4186/mod.rs   | 30 +++++++--------
 .../matrix-sdk-base/src/store/memory_store.rs | 36 +++++++++---------
 7 files changed, 105 insertions(+), 99 deletions(-)

diff --git a/vendored/matrix-sdk/crates/matrix-sdk-base/src/client.rs b/vendored/matrix-sdk/crates/matrix-sdk-base/src/client.rs
index 96ccde21a..afeba6940 100644
--- a/vendored/matrix-sdk/crates/matrix-sdk-base/src/client.rs
+++ b/vendored/matrix-sdk/crates/matrix-sdk-base/src/client.rs
@@ -499,14 +499,14 @@ impl BaseClient {
             // key bundle shortly after, we might accept it. If we don't do
             // this, the homeserver could trick us into accepting any historic room key
             // bundle.
-            if previous_state == RoomState::Invited
-                && let Some(inviter) = inviter
-            {
-                let details = InviteAcceptanceDetails {
-                    invite_accepted_at: MilliSecondsSinceUnixEpoch::now(),
-                    inviter,
-                };
-                room_info.set_invite_acceptance_details(details);
+            if previous_state == RoomState::Invited {
+                if let Some(inviter) = inviter {
+                    let details = InviteAcceptanceDetails {
+                        invite_accepted_at: MilliSecondsSinceUnixEpoch::now(),
+                        inviter,
+                    };
+                    room_info.set_invite_acceptance_details(details);
+                }
             }
 
             let mut changes = StateChanges::default();
@@ -884,11 +884,14 @@ impl BaseClient {
                 _ => (),
             }
 
-            if let StateEvent::Original(e) = &member
-                && let Some(d) = &e.content.displayname
-            {
-                let display_name = DisplayName::new(d);
-                ambiguity_map.entry(display_name).or_default().insert(member.state_key().clone());
+            if let StateEvent::Original(e) = &member {
+                if let Some(d) = &e.content.displayname {
+                    let display_name = DisplayName::new(d);
+                    ambiguity_map
+                        .entry(display_name)
+                        .or_default()
+                        .insert(member.state_key().clone());
+                }
             }
 
             let sync_member: SyncRoomMemberEvent = member.clone().into();
diff --git a/vendored/matrix-sdk/crates/matrix-sdk-base/src/latest_event.rs b/vendored/matrix-sdk/crates/matrix-sdk-base/src/latest_event.rs
index 41aafb00e..81a3fe2cd 100644
--- a/vendored/matrix-sdk/crates/matrix-sdk-base/src/latest_event.rs
+++ b/vendored/matrix-sdk/crates/matrix-sdk-base/src/latest_event.rs
@@ -125,21 +125,21 @@ pub fn is_suitable_for_latest_event<'a>(
         AnySyncTimelineEvent::State(state) => {
             // But we make an exception for knocked state events *if* the current user
             // can either accept or decline them
-            if let AnySyncStateEvent::RoomMember(member) = state
-                && matches!(member.membership(), MembershipState::Knock)
-            {
-                let can_accept_or_decline_knocks = match power_levels_info {
-                    Some((own_user_id, room_power_levels)) => {
-                        room_power_levels.user_can_invite(own_user_id)
-                            || room_power_levels.user_can_kick(own_user_id)
-                    }
-                    _ => false,
-                };
+            if let AnySyncStateEvent::RoomMember(member) = state {
+                if matches!(member.membership(), MembershipState::Knock) {
+                    let can_accept_or_decline_knocks = match power_levels_info {
+                        Some((own_user_id, room_power_levels)) => {
+                            room_power_levels.user_can_invite(own_user_id)
+                                || room_power_levels.user_can_kick(own_user_id)
+                        }
+                        _ => false,
+                    };
 
-                // The current user can act on the knock changes, so they should be
-                // displayed
-                if can_accept_or_decline_knocks {
-                    return PossibleLatestEvent::YesKnockedStateEvent(member);
+                    // The current user can act on the knock changes, so they should be
+                    // displayed
+                    if can_accept_or_decline_knocks {
+                        return PossibleLatestEvent::YesKnockedStateEvent(member);
+                    }
                 }
             }
             PossibleLatestEvent::NoUnsupportedEventType
diff --git a/vendored/matrix-sdk/crates/matrix-sdk-base/src/read_receipts.rs b/vendored/matrix-sdk/crates/matrix-sdk-base/src/read_receipts.rs
index f1c8517ae..0aa4f80a5 100644
--- a/vendored/matrix-sdk/crates/matrix-sdk-base/src/read_receipts.rs
+++ b/vendored/matrix-sdk/crates/matrix-sdk-base/src/read_receipts.rs
@@ -264,15 +264,15 @@ impl RoomReadReceipts {
             // Sliding sync sometimes sends the same event multiple times, so it can be at
             // the beginning and end of a batch, for instance. In that case, just reset
             // every time we see the event matching the receipt.
-            if let Some(event_id) = event.event_id()
-                && event_id == receipt_event_id
-            {
-                // Bingo! Switch over to the counting state, after resetting the
-                // previous counts.
-                trace!("Found the event the receipt was referring to! Starting to count.");
-                self.reset();
-                counting_receipts = true;
-                continue;
+            if let Some(event_id) = event.event_id() {
+                if event_id == receipt_event_id {
+                    // Bingo! Switch over to the counting state, after resetting the
+                    // previous counts.
+                    trace!("Found the event the receipt was referring to! Starting to count.");
+                    self.reset();
+                    counting_receipts = true;
+                    continue;
+                }
             }
 
             if counting_receipts {
@@ -387,17 +387,17 @@ impl ReceiptSelector {
         // Now consider new receipts.
         for (event_id, receipts) in &receipt_event.0 {
             for ty in [ReceiptType::Read, ReceiptType::ReadPrivate] {
-                if let Some(receipts) = receipts.get(&ty)
-                    && let Some(receipt) = receipts.get(user_id)
-                    && matches!(receipt.thread, ReceiptThread::Main | ReceiptThread::Unthreaded)
+                if let Some(receipt) = receipts.get(&ty).and_then(|receipts| receipts.get(user_id))
                 {
-                    trace!(%event_id, "found new candidate");
-                    if let Some(event_pos) = self.event_id_to_pos.get(event_id) {
-                        self.try_select_later(event_id, *event_pos);
-                    } else {
-                        // It's a new pending receipt.
-                        trace!(%event_id, "stashed as pending");
-                        pending.push(event_id.clone());
+                    if matches!(receipt.thread, ReceiptThread::Main | ReceiptThread::Unthreaded) {
+                        trace!(%event_id, "found new candidate");
+                        if let Some(event_pos) = self.event_id_to_pos.get(event_id) {
+                            self.try_select_later(event_id, *event_pos);
+                        } else {
+                            // It's a new pending receipt.
+                            trace!(%event_id, "stashed as pending");
+                            pending.push(event_id.clone());
+                        }
                     }
                 }
             }
diff --git a/vendored/matrix-sdk/crates/matrix-sdk-base/src/response_processors/account_data/global.rs b/vendored/matrix-sdk/crates/matrix-sdk-base/src/response_processors/account_data/global.rs
index e0be9ff67..8b702fa67 100644
--- a/vendored/matrix-sdk/crates/matrix-sdk-base/src/response_processors/account_data/global.rs
+++ b/vendored/matrix-sdk/crates/matrix-sdk-base/src/response_processors/account_data/global.rs
@@ -102,10 +102,10 @@ impl Global {
 
             // Update the direct targets of rooms if they changed.
             for (room_id, new_direct_targets) in new_dms {
-                if let Some(old_direct_targets) = old_dms.remove(&room_id)
-                    && old_direct_targets == new_direct_targets
-                {
-                    continue;
+                if let Some(old_direct_targets) = old_dms.remove(&room_id) {
+                    if old_direct_targets == new_direct_targets {
+                        continue;
+                    }
                 }
                 trace!(?room_id, targets = ?new_direct_targets, "Marking room as direct room");
                 map_info(room_id, state_changes, state_store, |info| {
diff --git a/vendored/matrix-sdk/crates/matrix-sdk-base/src/response_processors/e2ee/tracked_users.rs b/vendored/matrix-sdk/crates/matrix-sdk-base/src/response_processors/e2ee/tracked_users.rs
index 9ba0b5366..ddae727e5 100644
--- a/vendored/matrix-sdk/crates/matrix-sdk-base/src/response_processors/e2ee/tracked_users.rs
+++ b/vendored/matrix-sdk/crates/matrix-sdk-base/src/response_processors/e2ee/tracked_users.rs
@@ -25,11 +25,12 @@ pub async fn update(
     room_encryption_state: EncryptionState,
     user_ids_to_track: &BTreeSet<OwnedUserId>,
 ) -> Result<()> {
-    if room_encryption_state.is_encrypted()
-        && let Some(olm) = olm_machine
-        && !user_ids_to_track.is_empty()
-    {
-        olm.update_tracked_users(user_ids_to_track.iter().map(AsRef::as_ref)).await?
+    if room_encryption_state.is_encrypted() {
+        if let Some(olm) = olm_machine {
+            if !user_ids_to_track.is_empty() {
+                olm.update_tracked_users(user_ids_to_track.iter().map(AsRef::as_ref)).await?
+            }
+        }
     }
 
     Ok(())
@@ -45,19 +46,19 @@ pub async fn update_or_set_if_room_is_newly_encrypted(
     room_id: &RoomId,
     state_store: &BaseStateStore,
 ) -> Result<()> {
-    if new_room_encryption_state.is_encrypted()
-        && let Some(olm) = olm_machine
-    {
-        if !previous_room_encryption_state.is_encrypted() {
-            // The room turned on encryption in this sync, we need
-            // to also get all the existing users and mark them for
-            // tracking.
-            let user_ids = state_store.get_user_ids(room_id, RoomMemberships::ACTIVE).await?;
-            olm.update_tracked_users(user_ids.iter().map(AsRef::as_ref)).await?
-        }
+    if new_room_encryption_state.is_encrypted() {
+        if let Some(olm) = olm_machine {
+            if !previous_room_encryption_state.is_encrypted() {
+                // The room turned on encryption in this sync, we need
+                // to also get all the existing users and mark them for
+                // tracking.
+                let user_ids = state_store.get_user_ids(room_id, RoomMemberships::ACTIVE).await?;
+                olm.update_tracked_users(user_ids.iter().map(AsRef::as_ref)).await?
+            }
 
-        if !user_ids_to_track.is_empty() {
-            olm.update_tracked_users(user_ids_to_track.iter().map(AsRef::as_ref)).await?;
+            if !user_ids_to_track.is_empty() {
+                olm.update_tracked_users(user_ids_to_track.iter().map(AsRef::as_ref)).await?;
+            }
         }
     }
 
diff --git a/vendored/matrix-sdk/crates/matrix-sdk-base/src/response_processors/room/msc4186/mod.rs b/vendored/matrix-sdk/crates/matrix-sdk-base/src/response_processors/room/msc4186/mod.rs
index e339919bb..1682bbe56 100644
--- a/vendored/matrix-sdk/crates/matrix-sdk-base/src/response_processors/room/msc4186/mod.rs
+++ b/vendored/matrix-sdk/crates/matrix-sdk-base/src/response_processors/room/msc4186/mod.rs
@@ -242,10 +242,10 @@ fn membership(
         // We need to find the membership event since it could be for either an invited
         // or knocked room.
         let membership_event = state_events.1.iter().find_map(|event| {
-            if let AnyStrippedStateEvent::RoomMember(membership_event) = event
-                && membership_event.state_key == user_id
-            {
-                return Some(membership_event.content.clone());
+            if let AnyStrippedStateEvent::RoomMember(membership_event) = event {
+                if membership_event.state_key == user_id {
+                    return Some(membership_event.content.clone());
+                }
             }
             None
         });
@@ -498,17 +498,17 @@ pub(crate) async fn cache_latest_events(
                     }
 
                     // Otherwise, look up the sender's profile from the `Store`.
-                    if sender_profile.is_none()
-                        && let Some(store) = store
-                    {
-                        sender_profile = store
-                            .get_profile(room.room_id(), timeline_event.sender())
-                            .await
-                            .ok()
-                            .flatten();
-
-                        // TODO: need to update `sender_name_is_ambiguous`,
-                        // but how?
+                    if sender_profile.is_none() {
+                        if let Some(store) = store {
+                            sender_profile = store
+                                .get_profile(room.room_id(), timeline_event.sender())
+                                .await
+                                .ok()
+                                .flatten();
+
+                            // TODO: need to update `sender_name_is_ambiguous`,
+                            // but how?
+                        }
                     }
 
                     let latest_event = Box::new(LatestEvent::new_with_sender_details(
diff --git a/vendored/matrix-sdk/crates/matrix-sdk-base/src/store/memory_store.rs b/vendored/matrix-sdk/crates/matrix-sdk-base/src/store/memory_store.rs
index a974ac065..84e98791f 100644
--- a/vendored/matrix-sdk/crates/matrix-sdk-base/src/store/memory_store.rs
+++ b/vendored/matrix-sdk/crates/matrix-sdk-base/src/store/memory_store.rs
@@ -416,12 +416,14 @@ impl StateStore for MemoryStore {
                             .insert(user_id.clone(), (event_id.clone(), receipt.clone()))
                         {
                             // Remove the old receipt from the room event receipts
-                            if let Some(receipt_map) = inner.room_event_receipts.get_mut(room)
-                                && let Some(event_map) =
+                            if let Some(receipt_map) = inner.room_event_receipts.get_mut(room) {
+                                if let Some(event_map) =
                                     receipt_map.get_mut(&(receipt_type.to_string(), thread.clone()))
-                                && let Some(user_map) = event_map.get_mut(&old_event)
-                            {
-                                user_map.remove(user_id);
+                                {
+                                    if let Some(user_map) = event_map.get_mut(&old_event) {
+                                        user_map.remove(user_id);
+                                    }
+                                }
                             }
                         }
 
@@ -457,18 +459,18 @@ impl StateStore for MemoryStore {
             if let Some(room) = inner.room_state.get_mut(room_id) {
                 for ref_room_mu in room.values_mut() {
                     for raw_evt in ref_room_mu.values_mut() {
-                        if let Ok(Some(event_id)) = raw_evt.get_field::<OwnedEventId>("event_id")
-                            && let Some(redaction) = redactions.get(&event_id)
-                        {
-                            let redacted = redact(
-                                raw_evt.deserialize_as::<CanonicalJsonObject>()?,
-                                redaction_rules.get_or_insert_with(|| {
-                                    make_redaction_rules(&inner.room_info, room_id)
-                                }),
-                                Some(RedactedBecause::from_raw_event(redaction)?),
-                            )
-                            .map_err(StoreError::Redaction)?;
-                            *raw_evt = Raw::new(&redacted)?.cast_unchecked();
+                        if let Ok(Some(event_id)) = raw_evt.get_field::<OwnedEventId>("event_id") {
+                            if let Some(redaction) = redactions.get(&event_id) {
+                                let redacted = redact(
+                                    raw_evt.deserialize_as::<CanonicalJsonObject>()?,
+                                    redaction_rules.get_or_insert_with(|| {
+                                        make_redaction_rules(&inner.room_info, room_id)
+                                    }),
+                                    Some(RedactedBecause::from_raw_event(redaction)?),
+                                )
+                                .map_err(StoreError::Redaction)?;
+                                *raw_evt = Raw::new(&redacted)?.cast_unchecked();
+                            }
                         }
                     }
                 }
-- 
2.49.1

