From 68e28a4024530b3fa1888cf7cdf9043d25904113 Mon Sep 17 00:00:00 2001
From: Alan Modra <amodra@gmail.com>
Date: Thu, 6 Feb 2025 21:46:22 +1030
Subject: [PATCH] PR 32603, ld -w misbehaviour

ld -w currently causes segmentation faults and other misbehaviour
since it changes einfo with %F in the format string (fatal error) to
not exit.  This patch fixes that by introducing a new variant of einfo
called "fatal" that always exits, and replaces all einfo calls using
%F with a call to fatal without the %F.  I considered modifying einfo
to inspect the first 2 or 4 chars in the format string, looking for
%F, but decided that was probably a bad idea given that translators
might have moved the %F.  It's also a little nicer to inform the
compiler of a function that doesn't return.

The patch also fixes some formatting nits, and makes use of %pA
to print section names in a couple of places in aix.em.

(cherry picked from commit 8d97c1a53f3dc9fd8e1ccdb039b8a33d50133150)
(cherry picked from commit 0b7f992b78fe0984fc7d84cc748d0794e4a400e3)
---
 ld/emulparams/call_nop.sh            |  6 +-
 ld/emulparams/cet.sh                 |  2 +-
 ld/emulparams/elf32mcore.sh          |  2 +-
 ld/emulparams/x86-64-lam.sh          |  6 +-
 ld/emulparams/x86-64-level-report.sh |  2 +-
 ld/emulparams/x86-64-level.sh        |  2 +-
 ld/emultempl/aarch64elf.em           |  6 +-
 ld/emultempl/aix.em                  | 41 ++++++------
 ld/emultempl/armelf.em               | 10 +--
 ld/emultempl/avrelf.em               |  2 +-
 ld/emultempl/beos.em                 | 24 +++----
 ld/emultempl/cr16elf.em              |  4 +-
 ld/emultempl/cskyelf.em              |  4 +-
 ld/emultempl/elf.em                  | 16 ++---
 ld/emultempl/hppaelf.em              |  4 +-
 ld/emultempl/kvxelf.em               |  7 +-
 ld/emultempl/loongarchelf.em         |  4 +-
 ld/emultempl/m68hc1xelf.em           |  2 +-
 ld/emultempl/m68kelf.em              |  4 +-
 ld/emultempl/metagelf.em             |  4 +-
 ld/emultempl/mipself.em              |  2 +-
 ld/emultempl/mmix-elfnmmo.em         |  5 +-
 ld/emultempl/nds32elf.em             |  6 +-
 ld/emultempl/nto.em                  | 28 ++++----
 ld/emultempl/pe.em                   | 20 +++---
 ld/emultempl/pep.em                  | 16 ++---
 ld/emultempl/ppc32elf.em             |  4 +-
 ld/emultempl/ppc64elf.em             | 10 +--
 ld/emultempl/riscvelf.em             |  2 +-
 ld/emultempl/s390.em                 |  2 +-
 ld/emultempl/scoreelf.em             |  2 +-
 ld/emultempl/spuelf.em               | 20 +++---
 ld/emultempl/tic6xdsbt.em            | 10 ++-
 ld/emultempl/ticoff.em               |  4 +-
 ld/emultempl/v850elf.em              |  2 +-
 ld/emultempl/vms.em                  |  2 +-
 ld/emultempl/xtensaelf.em            | 12 ++--
 ld/emultempl/z80.em                  |  2 +-
 ld/ldcref.c                          |  8 +--
 ld/ldelf.c                           | 34 +++++-----
 ld/ldelfgen.c                        | 17 +++--
 ld/ldemul.c                          |  2 +-
 ld/ldexp.c                           | 42 ++++++------
 ld/ldfile.c                          | 14 ++--
 ld/ldgram.y                          |  6 +-
 ld/ldlang.c                          | 97 ++++++++++++++--------------
 ld/ldlex.l                           | 14 ++--
 ld/ldmain.c                          | 45 ++++++-------
 ld/ldmisc.c                          | 28 ++++++--
 ld/ldmisc.h                          |  1 +
 ld/ldwrite.c                         | 22 +++----
 ld/lexsup.c                          | 72 ++++++++++-----------
 ld/mri.c                             |  2 +-
 ld/pe-dll.c                          | 12 ++--
 ld/plugin.c                          | 27 ++++----
 55 files changed, 366 insertions(+), 378 deletions(-)

diff --git a/ld/emulparams/call_nop.sh b/ld/emulparams/call_nop.sh
index 2c3c305f0e8..7dd6dfb130c 100644
--- a/ld/emulparams/call_nop.sh
+++ b/ld/emulparams/call_nop.sh
@@ -20,7 +20,7 @@ PARSE_AND_LIST_ARGS_CASE_Z_CALL_NOP='
 	      char *end;
 	      params.call_nop_byte = strtoul (optarg + 16 , &end, 0);
 	      if (*end)
-		einfo (_("%F%P: invalid number for -z call-nop=prefix-: %s\n"),
+		fatal (_("%P: invalid number for -z call-nop=prefix-: %s\n"),
 		       optarg + 16);
 	      params.call_nop_as_suffix = false;
 	    }
@@ -29,12 +29,12 @@ PARSE_AND_LIST_ARGS_CASE_Z_CALL_NOP='
 	      char *end;
 	      params.call_nop_byte = strtoul (optarg + 16, &end, 0);
 	      if (*end)
-		einfo (_("%F%P: invalid number for -z call-nop=suffix-: %s\n"),
+		fatal (_("%P: invalid number for -z call-nop=suffix-: %s\n"),
 		       optarg + 16);
 	      params.call_nop_as_suffix = true;
 	    }
 	  else
-	    einfo (_("%F%P: unsupported option: -z %s\n"), optarg);
+	    fatal (_("%P: unsupported option: -z %s\n"), optarg);
 	}
 '
 
diff --git a/ld/emulparams/cet.sh b/ld/emulparams/cet.sh
index 2c627994501..e463441d176 100644
--- a/ld/emulparams/cet.sh
+++ b/ld/emulparams/cet.sh
@@ -29,7 +29,7 @@ PARSE_AND_LIST_ARGS_CASE_Z_CET='
 				 | prop_report_ibt
 				 | prop_report_shstk);
 	  else
-	    einfo (_("%F%P: invalid option for -z cet-report=: %s\n"),
+	    fatal (_("%P: invalid option for -z cet-report=: %s\n"),
 		   optarg + 11);
 	}
 '
diff --git a/ld/emulparams/elf32mcore.sh b/ld/emulparams/elf32mcore.sh
index 7d433fc0f2d..dc0f5d042e7 100644
--- a/ld/emulparams/elf32mcore.sh
+++ b/ld/emulparams/elf32mcore.sh
@@ -42,6 +42,6 @@ PARSE_AND_LIST_ARGS_CASES='
     case OPTION_BASE_FILE:
       link_info.base_file = fopen (optarg, FOPEN_WB);
       if (link_info.base_file == NULL)
-	einfo (_("%F%P: cannot open base file %s\n"), optarg);
+	fatal (_("%P: cannot open base file %s\n"), optarg);
       break;
 '
diff --git a/ld/emulparams/x86-64-lam.sh b/ld/emulparams/x86-64-lam.sh
index fab42ff1df2..6e629ebbac8 100644
--- a/ld/emulparams/x86-64-lam.sh
+++ b/ld/emulparams/x86-64-lam.sh
@@ -25,7 +25,7 @@ PARSE_AND_LIST_ARGS_CASE_Z_LAM='
 	  else if (strcmp (optarg + 15, "error") == 0)
 	    params.lam_u48_report = prop_report_error;
 	  else
-	    einfo (_("%F%P: invalid option for -z lam-u48-report=: %s\n"),
+	    fatal (_("%P: invalid option for -z lam-u48-report=: %s\n"),
 		   optarg + 15);
 	}
       else if (strcmp (optarg, "lam-u57") == 0)
@@ -39,7 +39,7 @@ PARSE_AND_LIST_ARGS_CASE_Z_LAM='
 	  else if (strcmp (optarg + 15, "error") == 0)
 	    params.lam_u57_report = prop_report_error;
 	  else
-	    einfo (_("%F%P: invalid option for -z lam-u57-report=: %s\n"),
+	    fatal (_("%P: invalid option for -z lam-u57-report=: %s\n"),
 		   optarg + 15);
 	}
       else if (strncmp (optarg, "lam-report=", 11) == 0)
@@ -60,7 +60,7 @@ PARSE_AND_LIST_ARGS_CASE_Z_LAM='
 	      params.lam_u57_report = prop_report_error;
 	    }
 	  else
-	    einfo (_("%F%P: invalid option for -z lam-report=: %s\n"),
+	    fatal (_("%P: invalid option for -z lam-report=: %s\n"),
 		   optarg + 11);
 	}
 '
diff --git a/ld/emulparams/x86-64-level-report.sh b/ld/emulparams/x86-64-level-report.sh
index 518527767a4..0463ad95269 100644
--- a/ld/emulparams/x86-64-level-report.sh
+++ b/ld/emulparams/x86-64-level-report.sh
@@ -16,7 +16,7 @@ PARSE_AND_LIST_ARGS_CASE_Z_X86_64_LEVEL_REPORT='
 	  else if (strcmp (optarg + 17, "used") == 0)
 	    params.isa_level_report = isa_level_report_used;
 	  else
-	    einfo (_("%F%P: invalid option for -z isa-level-report=: %s\n"),
+	    fatal (_("%P: invalid option for -z isa-level-report=: %s\n"),
 		   optarg + 17);
 	}
 '
diff --git a/ld/emulparams/x86-64-level.sh b/ld/emulparams/x86-64-level.sh
index c46aacf3aff..7e27cf1ea45 100644
--- a/ld/emulparams/x86-64-level.sh
+++ b/ld/emulparams/x86-64-level.sh
@@ -10,7 +10,7 @@ PARSE_AND_LIST_ARGS_CASE_Z_X86_64_LEVEL='
 	  char *end;
 	  unsigned int level = strtoul (optarg + 8 , &end, 10);
 	  if (*end != '\0' || level < 2 || level > 4)
-	    einfo (_("%F%P: invalid x86-64 ISA level: %s\n"), optarg);
+	    fatal (_("%P: invalid x86-64 ISA level: %s\n"), optarg);
 	  params.isa_level = level;
 	}
 '
diff --git a/ld/emultempl/aarch64elf.em b/ld/emultempl/aarch64elf.em
index aa2859d4f73..d93bdeadf19 100644
--- a/ld/emultempl/aarch64elf.em
+++ b/ld/emultempl/aarch64elf.em
@@ -316,7 +316,7 @@ aarch64_elf_create_output_section_statements (void)
 	 These will only be created if the output format is an arm format,
 	 hence we do not support linking and changing output formats at the
 	 same time.  Use a link followed by objcopy to change output formats.  */
-      einfo (_("%F%P: error: cannot change output format "
+      fatal (_("%P: error: cannot change output format "
 	       "whilst linking %s binaries\n"), "AArch64");
       return;
     }
@@ -342,7 +342,7 @@ aarch64_elf_create_output_section_statements (void)
 			      bfd_get_arch (link_info.output_bfd),
 			      bfd_get_mach (link_info.output_bfd)))
     {
-      einfo (_("%F%P: can not create BFD: %E\n"));
+      fatal (_("%P: can not create BFD: %E\n"));
       return;
     }
 
@@ -458,7 +458,7 @@ PARSE_AND_LIST_ARGS_CASES='
 
 	group_size = bfd_scan_vma (optarg, &end, 0);
 	if (*end)
-	  einfo (_("%F%P: invalid number `%s'\''\n"), optarg);
+	  fatal (_("%P: invalid number `%s'\''\n"), optarg);
       }
       break;
 '
diff --git a/ld/emultempl/aix.em b/ld/emultempl/aix.em
index 33857b5d49c..3661ff682dd 100644
--- a/ld/emultempl/aix.em
+++ b/ld/emultempl/aix.em
@@ -307,7 +307,7 @@ read_file_list (const char *filename)
   f = fopen (filename, FOPEN_RT);
   if (f == NULL)
     {
-      einfo (_("%F%P: cannot open %s\n"), filename);
+      fatal (_("%P: cannot open %s\n"), filename);
       return;
     }
   if (fseek (f, 0L, SEEK_END) == -1)
@@ -354,8 +354,8 @@ read_file_list (const char *filename)
   return;
 
  error:
-  einfo (_("%F%P: cannot read %s\n"), optarg);
   fclose (f);
+  fatal (_("%P: cannot read %s\n"), optarg);
 }
 
 static bool
@@ -706,7 +706,7 @@ gld${EMULATION_NAME}_after_open (void)
       size = (p->count + 2) * 4;
       if (!bfd_xcoff_link_record_set (link_info.output_bfd, &link_info,
 				      p->h, size))
-	einfo (_("%F%P: bfd_xcoff_link_record_set failed: %E\n"));
+	fatal (_("%P: bfd_xcoff_link_record_set failed: %E\n"));
     }
 }
 
@@ -736,9 +736,9 @@ gld${EMULATION_NAME}_before_allocation (void)
 
       h = bfd_link_hash_lookup (link_info.hash, el->name, false, false, false);
       if (h == NULL)
-	einfo (_("%F%P: bfd_link_hash_lookup of export symbol failed: %E\n"));
+	fatal (_("%P: bfd_link_hash_lookup of export symbol failed: %E\n"));
       if (!bfd_xcoff_export_symbol (link_info.output_bfd, &link_info, h))
-	einfo (_("%F%P: bfd_xcoff_export_symbol failed: %E\n"));
+	fatal (_("%P: bfd_xcoff_export_symbol failed: %E\n"));
     }
 
   /* Track down all relocations called for by the linker script (these
@@ -821,7 +821,7 @@ gld${EMULATION_NAME}_before_allocation (void)
       (link_info.output_bfd, &link_info, libpath, entry_symbol.name,
        file_align, maxstack, maxdata, gc && !unix_ld,
        modtype, textro, flags, special_sections, rtld))
-    einfo (_("%F%P: failed to set dynamic section sizes: %E\n"));
+    fatal (_("%P: failed to set dynamic section sizes: %E\n"));
 
   /* Look through the special sections, and put them in the right
      place in the link ordering.  This is especially magic.  */
@@ -843,8 +843,8 @@ gld${EMULATION_NAME}_before_allocation (void)
       is = NULL;
       os = lang_output_section_get (sec->output_section);
       if (os == NULL)
-	einfo (_("%F%P: can't find output section %s\n"),
-	       sec->output_section->name);
+	fatal (_("%P: can't find output section %pA\n"),
+	       sec->output_section);
 
       for (pls = &os->children.head; *pls != NULL; pls = &(*pls)->header.next)
 	{
@@ -880,8 +880,7 @@ gld${EMULATION_NAME}_before_allocation (void)
 
       if (is == NULL)
 	{
-	  einfo (_("%F%P: can't find %s in output section\n"),
-		 bfd_section_name (sec));
+	  fatal (_("%P: can't find %pA in output section\n"), sec);
 	}
 
       /* Now figure out where the section should go.  */
@@ -1134,7 +1133,7 @@ gld${EMULATION_NAME}_after_allocation (void)
 
   /* Now that everything is in place, finalize the dynamic sections.  */
   if (!bfd_xcoff_build_dynamic_sections (link_info.output_bfd, &link_info))
-    einfo (_("%F%P: failed to layout dynamic sections: %E\n"));
+    fatal (_("%P: failed to layout dynamic sections: %E\n"));
 
   if (!bfd_link_relocatable (&link_info))
     {
@@ -1285,7 +1284,7 @@ gld${EMULATION_NAME}_read_file (const char *filename, bool import)
   if (f == NULL)
     {
       bfd_set_error (bfd_error_system_call);
-      einfo ("%F%P: %s: %E\n", filename);
+      fatal ("%P: %s: %E\n", filename);
       return;
     }
 
@@ -1347,7 +1346,7 @@ gld${EMULATION_NAME}_read_file (const char *filename, bool import)
 	      obstack_free (o, obstack_base (o));
 	    }
 	  else if (*s == '(')
-	    einfo (_("%F%P:%s:%d: #! ([member]) is not supported "
+	    fatal (_("%P:%s:%d: #! ([member]) is not supported "
 		     "in import files\n"),
 		   filename, linenumber);
 	  else
@@ -1364,7 +1363,7 @@ gld${EMULATION_NAME}_read_file (const char *filename, bool import)
 	      *s = '\0';
 	      if (!bfd_xcoff_split_import_path (link_info.output_bfd,
 						start, &imppath, &impfile))
-		einfo (_("%F%P: could not parse import path: %E\n"));
+		fatal (_("%P: could not parse import path: %E\n"));
 	      while (ISSPACE (cs))
 		{
 		  ++s;
@@ -1519,10 +1518,10 @@ gld${EMULATION_NAME}_find_relocs (lang_statement_union_type *s)
 
       rs = &s->reloc_statement;
       if (rs->name == NULL)
-	einfo (_("%F%P: only relocations against symbols are permitted\n"));
+	fatal (_("%P: only relocations against symbols are permitted\n"));
       if (!bfd_xcoff_link_count_reloc (link_info.output_bfd, &link_info,
 				       rs->name))
-	einfo (_("%F%P: bfd_xcoff_link_count_reloc failed: %E\n"));
+	fatal (_("%P: bfd_xcoff_link_count_reloc failed: %E\n"));
     }
 
   if (s->header.type == lang_assignment_statement_enum)
@@ -1551,7 +1550,7 @@ gld${EMULATION_NAME}_find_exp_assignment (etree_type *exp)
 	  if (!bfd_xcoff_record_link_assignment (link_info.output_bfd,
 						 &link_info,
 						 exp->assign.dst))
-	    einfo (_("%F%P: failed to record assignment to %s: %E\n"),
+	    fatal (_("%P: failed to record assignment to %s: %E\n"),
 		   exp->assign.dst);
 	}
       gld${EMULATION_NAME}_find_exp_assignment (exp->assign.src);
@@ -1646,7 +1645,7 @@ gld${EMULATION_NAME}_create_output_section_statements (void)
 			     bfd_get_arch (link_info.output_bfd),
 			     bfd_get_mach (link_info.output_bfd)))
     {
-      einfo (_("%F%P: can not create stub BFD: %E\n"));
+      fatal (_("%P: can not create stub BFD: %E\n"));
       return;
     }
 
@@ -1656,7 +1655,7 @@ gld${EMULATION_NAME}_create_output_section_statements (void)
 
   /* Pass linker params to the back-end. */
   if (!bfd_xcoff_link_init (&link_info, &params))
-    einfo (_("%F%P: can not init BFD: %E\n"));
+    fatal (_("%P: can not init BFD: %E\n"));
 
   /* __rtinit */
   if (link_info.init_function != NULL
@@ -1673,7 +1672,7 @@ gld${EMULATION_NAME}_create_output_section_statements (void)
 				  bfd_get_arch (link_info.output_bfd),
 				  bfd_get_mach (link_info.output_bfd)))
 	{
-	  einfo (_("%F%P: can not create BFD: %E\n"));
+	  fatal (_("%P: can not create BFD: %E\n"));
 	  return;
 	}
 
@@ -1683,7 +1682,7 @@ gld${EMULATION_NAME}_create_output_section_statements (void)
 					    link_info.fini_function,
 					    rtld))
 	{
-	  einfo (_("%F%P: can not create BFD: %E\n"));
+	  fatal (_("%P: can not create BFD: %E\n"));
 	  return;
 	}
 
diff --git a/ld/emultempl/armelf.em b/ld/emultempl/armelf.em
index 8f501aed12a..850f86a32dc 100644
--- a/ld/emultempl/armelf.em
+++ b/ld/emultempl/armelf.em
@@ -521,7 +521,7 @@ arm_elf_create_output_section_statements (void)
 	 These will only be created if the output format is an arm format,
 	 hence we do not support linking and changing output formats at the
 	 same time.  Use a link followed by objcopy to change output formats.  */
-      einfo (_("%F%P: error: cannot change output format "
+      fatal (_("%P: error: cannot change output format "
 	       "whilst linking %s binaries\n"), "ARM");
       return;
     }
@@ -532,10 +532,10 @@ arm_elf_create_output_section_statements (void)
 					bfd_get_target (link_info.output_bfd));
 
       if (params.in_implib_bfd == NULL)
-	einfo (_("%F%P: %s: can't open: %E\n"), in_implib_filename);
+	fatal (_("%P: %s: can't open: %E\n"), in_implib_filename);
 
       if (!bfd_check_format (params.in_implib_bfd, bfd_object))
-	einfo (_("%F%P: %s: not a relocatable file: %E\n"), in_implib_filename);
+	fatal (_("%P: %s: not a relocatable file: %E\n"), in_implib_filename);
     }
 
   bfd_elf32_arm_set_target_params (link_info.output_bfd, &link_info, &params);
@@ -549,7 +549,7 @@ arm_elf_create_output_section_statements (void)
 			      bfd_get_arch (link_info.output_bfd),
 			      bfd_get_mach (link_info.output_bfd)))
     {
-      einfo (_("%F%P: can not create BFD: %E\n"));
+      fatal (_("%P: can not create BFD: %E\n"));
       return;
     }
 
@@ -709,7 +709,7 @@ PARSE_AND_LIST_ARGS_CASES='
 
 	group_size = bfd_scan_vma (optarg, &end, 0);
 	if (*end)
-	  einfo (_("%F%P: invalid number `%s'\''\n"), optarg);
+	  fatal (_("%P: invalid number `%s'\''\n"), optarg);
       }
       break;
 
diff --git a/ld/emultempl/avrelf.em b/ld/emultempl/avrelf.em
index 792be729299..1faccb63797 100644
--- a/ld/emultempl/avrelf.em
+++ b/ld/emultempl/avrelf.em
@@ -116,7 +116,7 @@ avr_elf_create_output_section_statements (void)
 
   if (bfd_get_flavour (link_info.output_bfd) != bfd_target_elf_flavour)
     {
-      einfo (_("%F%P: error: cannot change output format "
+      fatal (_("%P: error: cannot change output format "
 	       "whilst linking %s binaries\n"), "AVR");
       return;
     }
diff --git a/ld/emultempl/beos.em b/ld/emultempl/beos.em
index 29c386c61f8..62923e0a8cd 100644
--- a/ld/emultempl/beos.em
+++ b/ld/emultempl/beos.em
@@ -211,7 +211,7 @@ set_pe_subsystem (void)
 	  return;
 	}
     }
-  einfo (_("%F%P: invalid subsystem type %s\n"), optarg);
+  fatal (_("%P: invalid subsystem type %s\n"), optarg);
 }
 
 
@@ -221,9 +221,7 @@ set_pe_value (char *name)
   char *end;
   set_pe_name (name,  strtoul (optarg, &end, 0));
   if (end == optarg)
-    {
-      einfo (_("%F%P: invalid hex number for PE parameter '%s'\n"), optarg);
-    }
+    fatal (_("%P: invalid hex number for PE parameter '%s'\n"), optarg);
 
   optarg = end;
 }
@@ -238,9 +236,7 @@ set_pe_stack_heap (char *resname, char *comname)
       set_pe_value (comname);
     }
   else if (*optarg)
-    {
-      einfo (_("%F%P: strange hex info for PE parameter '%s'\n"), optarg);
-    }
+    fatal (_("%P: strange hex info for PE parameter '%s'\n"), optarg);
 }
 
 
@@ -255,7 +251,7 @@ gld${EMULATION_NAME}_handle_option (int optc)
     case OPTION_BASE_FILE:
       link_info.base_file = fopen (optarg, FOPEN_WB);
       if (link_info.base_file == NULL)
-	einfo (_("%F%P: cannot open base file %s\n"), optarg);
+	fatal (_("%P: cannot open base file %s\n"), optarg);
       break;
 
       /* PE options */
@@ -364,9 +360,7 @@ gld${EMULATION_NAME}_after_open (void)
      FIXME: This should be done via a function, rather than by
      including an internal BFD header.  */
   if (!obj_pe (link_info.output_bfd))
-    {
-      einfo (_("%F%P: PE operations on non PE file\n"));
-    }
+    fatal (_("%P: PE operations on non PE file\n"));
 
   pe_data(link_info.output_bfd)->pe_opthdr = pe;
   pe_data(link_info.output_bfd)->dll = init[DLLOFF].value;
@@ -415,12 +409,12 @@ sort_by_file_name (const void *a, const void *b)
 
       if (!bfd_get_section_contents (sa->owner, sa, &a_sec, (file_ptr) 0,
 				     (bfd_size_type) sizeof (a_sec)))
-	einfo (_("%F%P: %pB: can't read contents of section .idata: %E\n"),
+	fatal (_("%P: %pB: can't read contents of section .idata: %E\n"),
 	       sa->owner);
 
       if (!bfd_get_section_contents (sb->owner, sb, &b_sec, (file_ptr) 0,
 				     (bfd_size_type) sizeof (b_sec)))
-	einfo (_("%F%P: %pB: can't read contents of section .idata: %E\n"),
+	fatal (_("%P: %pB: can't read contents of section .idata: %E\n"),
 	       sb->owner);
 
       i = a_sec < b_sec ? -1 : 0;
@@ -652,7 +646,7 @@ gld${EMULATION_NAME}_place_orphan (asection *s,
   /* Everything from the '\$' on gets deleted so don't allow '\$' as the
      first character.  */
   if (*secname == '\$')
-    einfo (_("%F%P: section %s has '\$' as first character\n"), secname);
+    fatal (_("%P: section %s has '\$' as first character\n"), secname);
   if (strchr (secname + 1, '\$') == NULL)
     return NULL;
 
@@ -682,7 +676,7 @@ gld${EMULATION_NAME}_place_orphan (asection *s,
       }
   ps[0] = 0;
   if (l == NULL)
-    einfo (_("%F%P: *(%s\$) missing from linker script\n"), output_secname);
+    fatal (_("%P: *(%s\$) missing from linker script\n"), output_secname);
 
   /* Link the input section in and we're done for now.
      The sections still have to be sorted, but that has to wait until
diff --git a/ld/emultempl/cr16elf.em b/ld/emultempl/cr16elf.em
index 7d4f95070fd..5464edf10bc 100644
--- a/ld/emultempl/cr16elf.em
+++ b/ld/emultempl/cr16elf.em
@@ -58,7 +58,7 @@ cr16_elf_after_open (void)
 	     COFF and ELF.  */
 	  if (bfd_get_flavour (abfd) != bfd_target_coff_flavour
 	      && bfd_get_flavour (abfd) != bfd_target_elf_flavour)
-	    einfo (_("%F%P: %pB: all input objects must be COFF or ELF "
+	    fatal (_("%P: %pB: all input objects must be COFF or ELF "
 		     "for --embedded-relocs\n"));
 
 	  datasec = bfd_get_section_by_name (abfd, ".data.rel");
@@ -82,7 +82,7 @@ cr16_elf_after_open (void)
 						      | SEC_IN_MEMORY))
 		  || !bfd_set_section_alignment (relsec, 2)
 		  || !bfd_set_section_size (relsec, datasec->reloc_count * 8))
-		einfo (_("%F%P: %pB: can not create .emreloc section: %E\n"));
+		fatal (_("%P: %pB: can not create .emreloc section: %E\n"));
 	    }
 
 	  /* Double check that all other data sections are empty, as is
diff --git a/ld/emultempl/cskyelf.em b/ld/emultempl/cskyelf.em
index 64a6ddf61f8..4a517498482 100644
--- a/ld/emultempl/cskyelf.em
+++ b/ld/emultempl/cskyelf.em
@@ -151,7 +151,7 @@ csky_elf_create_output_section_statements (void)
 	  bfd_get_arch (link_info.output_bfd),
 	  bfd_get_mach (link_info.output_bfd)))
     {
-      einfo (_("%F%P: can not create BFD: %E\n"));
+      fatal (_("%P: can not create BFD: %E\n"));
       return;
     }
 
@@ -318,7 +318,7 @@ PARSE_AND_LIST_ARGS_CASES='
 
       group_size = bfd_scan_vma (optarg, &end, 0);
       if (*end)
-	einfo (_("%F%P: invalid number `%s'\''\n"), optarg);
+	fatal (_("%P: invalid number `%s'\''\n"), optarg);
     }
     break;
 '
diff --git a/ld/emultempl/elf.em b/ld/emultempl/elf.em
index 863657e12f5..46d2fe5d539 100644
--- a/ld/emultempl/elf.em
+++ b/ld/emultempl/elf.em
@@ -877,12 +877,12 @@ gld${EMULATION_NAME}_handle_option (int optc)
 	{
 #ifndef HAVE_ZSTD
 	  if (config.compress_debug == COMPRESS_DEBUG_ZSTD)
-	    einfo (_ ("%F%P: --compress-debug-sections=zstd: ld is not built "
-		  "with zstd support\n"));
+	    fatal (_("%P: --compress-debug-sections=zstd: ld is not built "
+		     "with zstd support\n"));
 #endif
 	}
       if (config.compress_debug == COMPRESS_UNKNOWN)
-	einfo (_("%F%P: invalid --compress-debug-sections option: \`%s'\n"),
+	fatal (_("%P: invalid --compress-debug-sections option: \`%s'\n"),
 	       optarg);
       break;
 
@@ -944,7 +944,7 @@ fragment <<EOF
 	  link_info.emit_gnu_hash = true;
 	}
       else
-	einfo (_("%F%P: invalid hash style \`%s'\n"), optarg);
+	fatal (_("%P: invalid hash style \`%s'\n"), optarg);
       break;
 
 EOF
@@ -964,7 +964,7 @@ fragment <<EOF
 	  link_info.maxpagesize = strtoul (optarg + 14, &end, 0);
 	  if (*end
 	      || (link_info.maxpagesize & (link_info.maxpagesize - 1)) != 0)
-	    einfo (_("%F%P: invalid maximum page size \`%s'\n"),
+	    fatal (_("%P: invalid maximum page size \`%s'\n"),
 		   optarg + 14);
 	  link_info.maxpagesize_is_set = true;
 	}
@@ -974,7 +974,7 @@ fragment <<EOF
 	  link_info.commonpagesize = strtoul (optarg + 17, &end, 0);
 	  if (*end
 	      || (link_info.commonpagesize & (link_info.commonpagesize - 1)) != 0)
-	    einfo (_("%F%P: invalid common page size \`%s'\n"),
+	    fatal (_("%P: invalid common page size \`%s'\n"),
 		   optarg + 17);
 	  link_info.commonpagesize_is_set = true;
 	}
@@ -983,7 +983,7 @@ fragment <<EOF
 	  char *end;
 	  link_info.stacksize = strtoul (optarg + 11, &end, 0);
 	  if (*end || link_info.stacksize < 0)
-	    einfo (_("%F%P: invalid stack size \`%s'\n"), optarg + 11);
+	    fatal (_("%P: invalid stack size \`%s'\n"), optarg + 11);
 	  if (!link_info.stacksize)
 	    /* Use -1 for explicit no-stack, because zero means
 	       'default'.   */
@@ -1022,7 +1022,7 @@ fragment <<EOF
 	  else if (strcmp (optarg, "start-stop-visibility=protected") == 0)
 	    link_info.start_stop_visibility = STV_PROTECTED;
 	  else
-	    einfo (_("%F%P: invalid visibility in \`-z %s'; "
+	    fatal (_("%P: invalid visibility in \`-z %s'; "
 		     "must be default, internal, hidden, or protected"),
 		   optarg);
 	}
diff --git a/ld/emultempl/hppaelf.em b/ld/emultempl/hppaelf.em
index 45257980831..9241334cb00 100644
--- a/ld/emultempl/hppaelf.em
+++ b/ld/emultempl/hppaelf.em
@@ -82,7 +82,7 @@ hppaelf_create_output_section_statements (void)
 			      bfd_get_arch (link_info.output_bfd),
 			      bfd_get_mach (link_info.output_bfd)))
     {
-      einfo (_("%F%P: can not create BFD: %E\n"));
+      fatal (_("%P: can not create BFD: %E\n"));
       return;
     }
 
@@ -346,7 +346,7 @@ PARSE_AND_LIST_ARGS_CASES='
 	const char *end;
 	group_size = bfd_scan_vma (optarg, &end, 0);
 	if (*end)
-	  einfo (_("%F%P: invalid number `%s'\''\n"), optarg);
+	  fatal (_("%P: invalid number `%s'\''\n"), optarg);
       }
       break;
 '
diff --git a/ld/emultempl/kvxelf.em b/ld/emultempl/kvxelf.em
index 2076c5b6884..1ffbd1dbb34 100644
--- a/ld/emultempl/kvxelf.em
+++ b/ld/emultempl/kvxelf.em
@@ -35,9 +35,8 @@ elf${ELFSIZE}_kvx_before_allocation (void)
 EOF
 if test x"${EMULATION_NAME}" != x"elf64kvx_linux"; then
 fragment <<EOF
-  if (bfd_link_pie (&link_info)) {
-          einfo (_("%F:%P: -pie not supported\n"));
-  }
+  if (bfd_link_pie (&link_info))
+    fatal (_(":%P: -pie not supported\n"));
 EOF
 fi
 fragment <<EOF
@@ -300,7 +299,7 @@ kvx_elf_create_output_section_statements (void)
   ldlang_add_file (stub_file);
 
   if (!kvx_elf${ELFSIZE}_init_stub_bfd (&link_info, stub_file->the_bfd))
-    einfo ("%F%P: can not init BFD: %E\n");
+    einfo ("%P: can not init BFD: %E\n");
 }
 
 
diff --git a/ld/emultempl/loongarchelf.em b/ld/emultempl/loongarchelf.em
index 2da40582008..a50c8a8cbbe 100644
--- a/ld/emultempl/loongarchelf.em
+++ b/ld/emultempl/loongarchelf.em
@@ -83,11 +83,11 @@ gld${EMULATION_NAME}_after_allocation (void)
       && !bfd_link_relocatable (&link_info))
     {
       if (lang_phdr_list == NULL)
-        elf_seg_map (link_info.output_bfd) = NULL;
+	elf_seg_map (link_info.output_bfd) = NULL;
       if (!_bfd_elf_map_sections_to_segments (link_info.output_bfd,
 					      &link_info,
 					      NULL))
-        einfo (_("%F%P: map sections to segments failed: %E\n"));
+	fatal (_("%P: map sections to segments failed: %E\n"));
     }
 
   /* Adjust program header size and .eh_frame_hdr size before
diff --git a/ld/emultempl/m68hc1xelf.em b/ld/emultempl/m68hc1xelf.em
index 7aaa78a72d5..ab2600c7a67 100644
--- a/ld/emultempl/m68hc1xelf.em
+++ b/ld/emultempl/m68hc1xelf.em
@@ -159,7 +159,7 @@ m68hc11elf_create_output_section_statements (void)
 			     bfd_get_arch (link_info.output_bfd),
 			     bfd_get_mach (link_info.output_bfd)))
     {
-      einfo (_("%F%P: can not create BFD: %E\n"));
+      fatal (_("%P: can not create BFD: %E\n"));
       return;
     }
 
diff --git a/ld/emultempl/m68kelf.em b/ld/emultempl/m68kelf.em
index 30e7d171f6a..3d03da65b3f 100644
--- a/ld/emultempl/m68kelf.em
+++ b/ld/emultempl/m68kelf.em
@@ -82,7 +82,7 @@ m68k_elf_after_open (void)
 	  asection *datasec;
 
 	  if (bfd_get_flavour (abfd) != bfd_target_elf_flavour)
-	    einfo (_("%F%P: %pB: all input objects must be ELF "
+	    fatal (_("%P: %pB: all input objects must be ELF "
 		     "for --embedded-relocs\n"));
 
 	  datasec = bfd_get_section_by_name (abfd, ".data");
@@ -106,7 +106,7 @@ m68k_elf_after_open (void)
 	      if (relsec == NULL
 		  || !bfd_set_section_alignment (relsec, 2)
 		  || !bfd_set_section_size (relsec, datasec->reloc_count * 12))
-		einfo (_("%F%P: %pB: can not create .emreloc section: %E\n"));
+		fatal (_("%P: %pB: can not create .emreloc section: %E\n"));
 	    }
 
 	  /* Double check that all other data sections are empty, as is
diff --git a/ld/emultempl/metagelf.em b/ld/emultempl/metagelf.em
index 10d3ff10def..1ea8e87599a 100644
--- a/ld/emultempl/metagelf.em
+++ b/ld/emultempl/metagelf.em
@@ -59,7 +59,7 @@ metagelf_create_output_section_statements (void)
 			      bfd_get_arch (link_info.output_bfd),
 			      bfd_get_mach (link_info.output_bfd)))
     {
-      einfo (_("%F%P: can not create BFD: %E\n"));
+      fatal (_("%P: can not create BFD: %E\n"));
       return;
     }
 
@@ -305,7 +305,7 @@ PARSE_AND_LIST_ARGS_CASES='
 	const char *end;
 	group_size = bfd_scan_vma (optarg, &end, 0);
 	if (*end)
-	  einfo (_("%F%P: invalid number `%s'\''\n"), optarg);
+	  fatal (_("%P: invalid number `%s'\''\n"), optarg);
       }
       break;
 '
diff --git a/ld/emultempl/mipself.em b/ld/emultempl/mipself.em
index 3259f654b36..fd33be55f82 100644
--- a/ld/emultempl/mipself.em
+++ b/ld/emultempl/mipself.em
@@ -152,7 +152,7 @@ mips_add_stub_section (const char *stub_sec_name, asection *input_section,
 				 bfd_get_arch (link_info.output_bfd),
 				 bfd_get_mach (link_info.output_bfd)))
 	{
-	  einfo (_("%F%P: can not create BFD: %E\n"));
+	  fatal (_("%P: can not create BFD: %E\n"));
 	  return NULL;
 	}
       stub_bfd->flags |= BFD_LINKER_CREATED;
diff --git a/ld/emultempl/mmix-elfnmmo.em b/ld/emultempl/mmix-elfnmmo.em
index f2ecbba33cd..0318636305a 100644
--- a/ld/emultempl/mmix-elfnmmo.em
+++ b/ld/emultempl/mmix-elfnmmo.em
@@ -113,10 +113,7 @@ mmix_after_allocation (void)
     bfd_set_section_vma (sec, 0);
 
   if (!_bfd_mmix_after_linker_allocation (link_info.output_bfd, &link_info))
-    {
-      /* This is a fatal error; make einfo call not return.  */
-      einfo (_("%F%P: can't finalize linker-allocated global registers\n"));
-    }
+    fatal (_("%P: can't finalize linker-allocated global registers\n"));
 }
 EOF
 
diff --git a/ld/emultempl/nds32elf.em b/ld/emultempl/nds32elf.em
index 260e2a46e5d..0f3a8b922cf 100644
--- a/ld/emultempl/nds32elf.em
+++ b/ld/emultempl/nds32elf.em
@@ -44,7 +44,7 @@ nds32_elf_create_output_section_statements (void)
   if (strstr (bfd_get_target (link_info.output_bfd), "nds32") == NULL)
     {
       /* Check the output target is nds32.  */
-      einfo (_("%F%P: error: cannot change output format whilst "
+      fatal (_("%P: error: cannot change output format whilst "
 	       "linking %s binaries\n"), "NDS32");
       return;
     }
@@ -96,7 +96,7 @@ nds32_elf_after_open (void)
 	       && abi_ver != (elf_elfheader (abfd)->e_flags & EF_NDS_ABI))
 	{
 	  /* Incompatible objects.  */
-	  einfo (_("%F%P: %pB: ABI version of object files mismatched\n"),
+	  fatal (_("%P: %pB: ABI version of object files mismatched\n"),
 		 abfd);
 	}
     }
@@ -183,7 +183,7 @@ PARSE_AND_LIST_ARGS_CASES='
       {
 	sym_ld_script = fopen (optarg, FOPEN_WT);
 	if(sym_ld_script == NULL)
-	  einfo (_("%F%P: cannot open map file %s: %E\n"), optarg);
+	  fatal (_("%P: cannot open map file %s: %E\n"), optarg);
       }
     break;
   case OPTION_HYPER_RELAX:
diff --git a/ld/emultempl/nto.em b/ld/emultempl/nto.em
index 7cda6650bc6..57b96ccf885 100644
--- a/ld/emultempl/nto.em
+++ b/ld/emultempl/nto.em
@@ -51,7 +51,7 @@ nto_create_QNX_note_section(int type)
      is called before this function, stub_file should already be defined.  */
   if (!stub_file)
     {
-      einfo (_("%F%P: cannot create .note section in stub BFD.\n"));
+      fatal (_("%P: cannot create .note section in stub BFD.\n"));
       return NULL;
     }
 
@@ -60,7 +60,7 @@ nto_create_QNX_note_section(int type)
   note_sec = bfd_make_section_anyway_with_flags (stub_file->the_bfd, ".note", flags);
   if (! note_sec)
     {
-      einfo (_("%F%P: failed to create .note section\n"));
+      fatal (_("%P: failed to create .note section\n"));
       return NULL;
     }
 
@@ -101,7 +101,7 @@ nto_lookup_QNX_note_section(int type)
       sec->contents = xmalloc(sec->size);
       if (!bfd_get_section_contents (sec->owner, sec, sec->contents, (file_ptr) 0,
 				     sec->size))
-	einfo (_("%F%P: %pB: can't read contents of section .note: %E\n"),
+	fatal (_("%P: %pB: can't read contents of section .note: %E\n"),
 	       sec->owner);
 
       e_note = (Elf_External_Note *) sec->contents;
@@ -144,7 +144,7 @@ nto_add_note_section (void) {
 
   if (nto_lazy_stack && !link_info.stacksize)
     {
-      einfo (_("%F%P: error: --lazy-stack must follow -zstack-size=<size>\n"));
+      fatal (_("%P: error: --lazy-stack must follow -zstack-size=<size>\n"));
       return;
     }
 
@@ -198,22 +198,22 @@ PARSE_AND_LIST_LONGOPTS=${PARSE_AND_LIST_LONGOPTS}'
 PARSE_AND_LIST_OPTIONS=${PARSE_AND_LIST_OPTIONS}'
   fprintf (file, _("\
   --stack <size>              Set size of the initial stack\n\
-  --lazy-stack		      Set lazy allocation of stack\n\
+  --lazy-stack                Set lazy allocation of stack\n\
 "));
 '
 
 PARSE_AND_LIST_ARGS_CASES=${PARSE_AND_LIST_ARGS_CASES}'
     case OPTION_STACK:
       {
-        char *end;
-        link_info.stacksize = strtoul (optarg, &end, 0);
-        if (*end || link_info.stacksize < 0)
-          einfo (_("%F%P: invalid stack size `%s'\''\n"), optarg + 11);
-        if (!link_info.stacksize)
-          /* Use -1 for explicit no-stack, because zero means
-             'default'.   */
-          link_info.stacksize = -1;
-        break;
+	char *end;
+	link_info.stacksize = strtoul (optarg, &end, 0);
+	if (*end || link_info.stacksize < 0)
+	  fatal (_("%P: invalid stack size `%s'\''\n"), optarg + 11);
+	if (!link_info.stacksize)
+	  /* Use -1 for explicit no-stack, because zero means
+	     'default'.   */
+	  link_info.stacksize = -1;
+	break;
       }
     case OPTION_LAZY_STACK:
       nto_lazy_stack = true;
diff --git a/ld/emultempl/pe.em b/ld/emultempl/pe.em
index 9ab5e6ef481..f0dd1ed9ec9 100644
--- a/ld/emultempl/pe.em
+++ b/ld/emultempl/pe.em
@@ -648,7 +648,7 @@ set_pe_subsystem (void)
 
       if (v[i].name == NULL)
 	{
-	  einfo (_("%F%P: invalid subsystem type %s\n"), optarg);
+	  fatal (_("%P: invalid subsystem type %s\n"), optarg);
 	  return;
 	}
 
@@ -669,7 +669,7 @@ set_pe_value (char *name)
   set_pe_name (name,  strtoul (optarg, &end, 0));
 
   if (end == optarg)
-    einfo (_("%F%P: invalid hex number for PE parameter '%s'\n"), optarg);
+    fatal (_("%P: invalid hex number for PE parameter '%s'\n"), optarg);
 
   optarg = end;
 }
@@ -686,7 +686,7 @@ set_pe_stack_heap (char *resname, char *comname)
       set_pe_value (comname);
     }
   else if (*optarg)
-    einfo (_("%F%P: strange hex info for PE parameter '%s'\n"), optarg);
+    fatal (_("%P: strange hex info for PE parameter '%s'\n"), optarg);
 }
 
 #define DEFAULT_BUILD_ID_STYLE	"md5"
@@ -702,7 +702,7 @@ gld${EMULATION_NAME}_handle_option (int optc)
     case OPTION_BASE_FILE:
       link_info.base_file = fopen (optarg, FOPEN_WB);
       if (link_info.base_file == NULL)
-	einfo (_("%F%P: cannot open base file %s\n"), optarg);
+	fatal (_("%P: cannot open base file %s\n"), optarg);
       break;
 
       /* PE options.  */
@@ -1231,7 +1231,7 @@ make_runtime_ref (void)
     = bfd_wrapped_link_hash_lookup (link_info.output_bfd, &link_info,
 				    rr, true, false, true);
   if (!h)
-    einfo (_("%F%P: bfd_link_hash_lookup failed: %E\n"));
+    fatal (_("%P: bfd_link_hash_lookup failed: %E\n"));
   else
     {
       if (h->type == bfd_link_hash_new)
@@ -1529,7 +1529,7 @@ gld${EMULATION_NAME}_after_open (void)
   if (bfd_get_flavour (link_info.output_bfd) != bfd_target_coff_flavour
       || coff_data (link_info.output_bfd) == NULL
       || !obj_pe (link_info.output_bfd))
-    einfo (_("%F%P: cannot perform PE operations on non PE output file '%pB'\n"),
+    fatal (_("%P: cannot perform PE operations on non PE output file '%pB'\n"),
 	   link_info.output_bfd);
 
   pe_data (link_info.output_bfd)->pe_opthdr = pe;
@@ -1602,7 +1602,7 @@ gld${EMULATION_NAME}_after_open (void)
 	 These will only be created if the output format is an arm format,
 	 hence we do not support linking and changing output formats at the
 	 same time.  Use a link followed by objcopy to change output formats.  */
-      einfo (_("%F%P: error: cannot change output format "
+      fatal (_("%P: error: cannot change output format "
 	       "whilst linking %s binaries\n"), "ARM");
       return;
     }
@@ -1662,7 +1662,7 @@ gld${EMULATION_NAME}_after_open (void)
 
 		    if (!bfd_generic_link_read_symbols (is->the_bfd))
 		      {
-			einfo (_("%F%P: %pB: could not read symbols: %E\n"),
+			fatal (_("%P: %pB: could not read symbols: %E\n"),
 			       is->the_bfd);
 			return;
 		      }
@@ -1834,7 +1834,7 @@ gld${EMULATION_NAME}_after_open (void)
 
 		if (!bfd_generic_link_read_symbols (is->the_bfd))
 		  {
-		    einfo (_("%F%P: %pB: could not read symbols: %E\n"),
+		    fatal (_("%P: %pB: could not read symbols: %E\n"),
 			   is->the_bfd);
 		    return;
 		  }
@@ -1945,7 +1945,7 @@ gld${EMULATION_NAME}_unrecognized_file (lang_input_statement_type *entry ATTRIBU
 
 	      h = bfd_link_hash_lookup (link_info.hash, buf, true, true, true);
 	      if (h == (struct bfd_link_hash_entry *) NULL)
-		einfo (_("%F%P: bfd_link_hash_lookup failed: %E\n"));
+		fatal (_("%P: bfd_link_hash_lookup failed: %E\n"));
 	      if (h->type == bfd_link_hash_new)
 		{
 		  h->type = bfd_link_hash_undefined;
diff --git a/ld/emultempl/pep.em b/ld/emultempl/pep.em
index 00c4ea9e15a..af1f4655a47 100644
--- a/ld/emultempl/pep.em
+++ b/ld/emultempl/pep.em
@@ -625,7 +625,7 @@ set_pep_subsystem (void)
 
       if (v[i].name == NULL)
 	{
-	  einfo (_("%F%P: invalid subsystem type %s\n"), optarg);
+	  fatal (_("%P: invalid subsystem type %s\n"), optarg);
 	  return;
 	}
 
@@ -646,7 +646,7 @@ set_pep_value (char *name)
   set_pep_name (name,  (bfd_vma) strtoull (optarg, &end, 0));
 
   if (end == optarg)
-    einfo (_("%F%P: invalid hex number for PE parameter '%s'\n"), optarg);
+    fatal (_("%P: invalid hex number for PE parameter '%s'\n"), optarg);
 
   optarg = end;
 }
@@ -663,7 +663,7 @@ set_pep_stack_heap (char *resname, char *comname)
       set_pep_value (comname);
     }
   else if (*optarg)
-    einfo (_("%F%P: strange hex info for PE parameter '%s'\n"), optarg);
+    fatal (_("%P: strange hex info for PE parameter '%s'\n"), optarg);
 }
 
 #define DEFAULT_BUILD_ID_STYLE	"md5"
@@ -680,7 +680,7 @@ gld${EMULATION_NAME}_handle_option (int optc)
     case OPTION_BASE_FILE:
       link_info.base_file = fopen (optarg, FOPEN_WB);
       if (link_info.base_file == NULL)
-	einfo (_("%F%P: cannot open base file %s\n"), optarg);
+	fatal (_("%P: cannot open base file %s\n"), optarg);
       break;
 
       /* PE options.  */
@@ -1233,7 +1233,7 @@ make_runtime_ref (void)
     = bfd_wrapped_link_hash_lookup (link_info.output_bfd, &link_info,
 				    rr, true, false, true);
   if (!h)
-    einfo (_("%F%P: bfd_link_hash_lookup failed: %E\n"));
+    fatal (_("%P: bfd_link_hash_lookup failed: %E\n"));
   else
     {
       if (h->type == bfd_link_hash_new)
@@ -1533,7 +1533,7 @@ gld${EMULATION_NAME}_after_open (void)
   if (bfd_get_flavour (link_info.output_bfd) != bfd_target_coff_flavour
       || coff_data (link_info.output_bfd) == NULL
       || !obj_pe (link_info.output_bfd))
-    einfo (_("%F%P: cannot perform PE operations on non PE output file '%pB'\n"),
+    fatal (_("%P: cannot perform PE operations on non PE output file '%pB'\n"),
 	   link_info.output_bfd);
 
   pe_data (link_info.output_bfd)->pe_opthdr = pep;
@@ -1645,7 +1645,7 @@ gld${EMULATION_NAME}_after_open (void)
 
 		    if (!bfd_generic_link_read_symbols (is->the_bfd))
 		      {
-			einfo (_("%F%P: %pB: could not read symbols: %E\n"),
+			fatal (_("%P: %pB: could not read symbols: %E\n"),
 			       is->the_bfd);
 			return;
 		      }
@@ -1834,7 +1834,7 @@ gld${EMULATION_NAME}_unrecognized_file (lang_input_statement_type *entry ATTRIBU
 
 	      h = bfd_link_hash_lookup (link_info.hash, buf, true, true, true);
 	      if (h == (struct bfd_link_hash_entry *) NULL)
-		einfo (_("%F%P: bfd_link_hash_lookup failed: %E\n"));
+		fatal (_("%P: bfd_link_hash_lookup failed: %E\n"));
 	      if (h->type == bfd_link_hash_new)
 		{
 		  h->type = bfd_link_hash_undefined;
diff --git a/ld/emultempl/ppc32elf.em b/ld/emultempl/ppc32elf.em
index 12476f44fcf..61e275f4f9c 100644
--- a/ld/emultempl/ppc32elf.em
+++ b/ld/emultempl/ppc32elf.em
@@ -366,7 +366,7 @@ PARSE_AND_LIST_ARGS_CASES=${PARSE_AND_LIST_ARGS_CASES}'
 	  char *end;
 	  unsigned long val = strtoul (optarg, &end, 0);
 	  if (*end || val > 5)
-	    einfo (_("%F%P: invalid --plt-align `%s'\''\n"), optarg);
+	    fatal (_("%P: invalid --plt-align `%s'\''\n"), optarg);
 	  params.plt_stub_align = val;
 	}
       else
@@ -399,7 +399,7 @@ PARSE_AND_LIST_ARGS_CASES=${PARSE_AND_LIST_ARGS_CASES}'
 	  if (*end
 	      || (params.pagesize < 4096 && params.pagesize != 0)
 	      || params.pagesize != (params.pagesize & -params.pagesize))
-	    einfo (_("%F%P: invalid pagesize `%s'\''\n"), optarg);
+	    fatal (_("%P: invalid pagesize `%s'\''\n"), optarg);
 	}
       break;
 
diff --git a/ld/emultempl/ppc64elf.em b/ld/emultempl/ppc64elf.em
index 23905e9bc88..dfb5574114b 100644
--- a/ld/emultempl/ppc64elf.em
+++ b/ld/emultempl/ppc64elf.em
@@ -91,7 +91,7 @@ ppc_create_output_section_statements (void)
 			     bfd_get_arch (link_info.output_bfd),
 			     bfd_get_mach (link_info.output_bfd)))
     {
-      einfo (_("%F%P: can not create BFD: %E\n"));
+      fatal (_("%P: can not create BFD: %E\n"));
       return;
     }
 
@@ -101,7 +101,7 @@ ppc_create_output_section_statements (void)
   if (params.save_restore_funcs < 0)
     params.save_restore_funcs = !bfd_link_relocatable (&link_info);
   if (!ppc64_elf_init_stub_bfd (&link_info, &params))
-    einfo (_("%F%P: can not init BFD: %E\n"));
+    fatal (_("%P: can not init BFD: %E\n"));
 }
 
 /* Called after opening files but before mapping sections.  */
@@ -825,7 +825,7 @@ PARSE_AND_LIST_ARGS_CASES=${PARSE_AND_LIST_ARGS_CASES}'
 	const char *end;
 	params.group_size = bfd_scan_vma (optarg, &end, 0);
 	if (*end)
-	  einfo (_("%F%P: invalid number `%s'\''\n"), optarg);
+	  fatal (_("%P: invalid number `%s'\''\n"), optarg);
       }
       break;
 
@@ -851,7 +851,7 @@ PARSE_AND_LIST_ARGS_CASES=${PARSE_AND_LIST_ARGS_CASES}'
 	  char *end;
 	  long val = strtol (optarg, &end, 0);
 	  if (*end || (unsigned long) val + 8 > 16)
-	    einfo (_("%F%P: invalid --plt-align `%s'\''\n"), optarg);
+	    fatal (_("%P: invalid --plt-align `%s'\''\n"), optarg);
 	  params.plt_stub_align = val;
 	}
       else
@@ -880,7 +880,7 @@ PARSE_AND_LIST_ARGS_CASES=${PARSE_AND_LIST_ARGS_CASES}'
 	  else if (strcasecmp (optarg, "no") == 0)
 	    params.power10_stubs = 0;
 	  else
-	    einfo (_("%F%P: invalid --power10-stubs argument `%s'\''\n"),
+	    fatal (_("%P: invalid --power10-stubs argument `%s'\''\n"),
 		   optarg);
 	}
       else
diff --git a/ld/emultempl/riscvelf.em b/ld/emultempl/riscvelf.em
index afc43ed55dc..f69a4f9d111 100644
--- a/ld/emultempl/riscvelf.em
+++ b/ld/emultempl/riscvelf.em
@@ -131,7 +131,7 @@ riscv_create_output_section_statements (void)
 	 These will only be created if the output format is a RISC-V format,
 	 hence we do not support linking and changing output formats at the
 	 same time.  Use a link followed by objcopy to change output formats.  */
-      einfo (_("%F%P: error: cannot change output format"
+      fatal (_("%P: error: cannot change output format"
 	       " whilst linking %s binaries\n"), "RISC-V");
       return;
     }
diff --git a/ld/emultempl/s390.em b/ld/emultempl/s390.em
index 179cbbd98d7..10225f3f8e5 100644
--- a/ld/emultempl/s390.em
+++ b/ld/emultempl/s390.em
@@ -34,7 +34,7 @@ static void
 s390_elf_create_output_section_statements (void)
 {
   if (!bfd_elf_s390_set_options (&link_info, &params))
-    einfo (_("%F%P: can not init BFD: %E\n"));
+    fatal (_("%P: can not init BFD: %E\n"));
 }
 
 EOF
diff --git a/ld/emultempl/scoreelf.em b/ld/emultempl/scoreelf.em
index 499a583decd..70f693c6d6e 100644
--- a/ld/emultempl/scoreelf.em
+++ b/ld/emultempl/scoreelf.em
@@ -62,7 +62,7 @@ score_elf_after_open (void)
 	 These will only be created if the output format is an score format,
 	 hence we do not support linking and changing output formats at the
 	 same time.  Use a link followed by objcopy to change output formats.  */
-      einfo (_("%F%P: error: cannot change output format "
+      fatal (_("%P: error: cannot change output format "
 	       "whilst linking %s binaries\n"), "S+core");
       return;
     }
diff --git a/ld/emultempl/spuelf.em b/ld/emultempl/spuelf.em
index 2ff41b1e46e..610666e7644 100644
--- a/ld/emultempl/spuelf.em
+++ b/ld/emultempl/spuelf.em
@@ -202,7 +202,7 @@ spu_elf_load_ovl_mgr (void)
       /* User supplied __ovly_load.  */
     }
   else if (mgr_stream->start == mgr_stream->end)
-    einfo (_("%F%P: no built-in overlay manager\n"));
+    fatal (_("%P: no built-in overlay manager\n"));
   else
     {
       lang_input_statement_type *ovl_is;
@@ -379,7 +379,7 @@ spu_elf_open_overlay_script (void)
   if (script == NULL)
     {
     file_err:
-      einfo (_("%F%P: can not open script: %E\n"));
+      fatal (_("%P: can not open script: %E\n"));
     }
   return script;
 }
@@ -695,7 +695,7 @@ PARSE_AND_LIST_ARGS_CASES='
 	    if (*end == 0)
 	      break;
 	  }
-	einfo (_("%F%P: invalid --local-store address range `%s'\''\n"), optarg);
+	fatal (_("%P: invalid --local-store address range `%s'\''\n"), optarg);
       }
       break;
 
@@ -731,12 +731,12 @@ PARSE_AND_LIST_ARGS_CASES='
       if (!num_lines_set)
 	params.num_lines = 32;
       else if ((params.num_lines & -params.num_lines) != params.num_lines)
-	einfo (_("%F%P: invalid --num-lines/--num-regions `%u'\''\n"),
+	fatal (_("%P: invalid --num-lines/--num-regions `%u'\''\n"),
 	       params.num_lines);
       if (!line_size_set)
 	params.line_size = 1024;
       else if ((params.line_size & -params.line_size) != params.line_size)
-	einfo (_("%F%P: invalid --line-size/--region-size `%u'\''\n"),
+	fatal (_("%P: invalid --line-size/--region-size `%u'\''\n"),
 	       params.line_size);
       break;
 
@@ -757,7 +757,7 @@ PARSE_AND_LIST_ARGS_CASES='
 	    && (params.ovly_flavour != ovly_soft_icache
 		|| (params.num_lines & -params.num_lines) == params.num_lines))
 	  break;
-	einfo (_("%F%P: invalid --num-lines/--num-regions `%s'\''\n"), optarg);
+	fatal (_("%P: invalid --num-lines/--num-regions `%s'\''\n"), optarg);
       }
       break;
 
@@ -770,7 +770,7 @@ PARSE_AND_LIST_ARGS_CASES='
 	    && (params.ovly_flavour != ovly_soft_icache
 		|| (params.line_size & -params.line_size) == params.line_size))
 	  break;
-	einfo (_("%F%P: invalid --line-size/--region-size `%s'\''\n"), optarg);
+	fatal (_("%P: invalid --line-size/--region-size `%s'\''\n"), optarg);
       }
       break;
 
@@ -779,7 +779,7 @@ PARSE_AND_LIST_ARGS_CASES='
 	char *end;
 	params.auto_overlay_fixed = strtoul (optarg, &end, 0);
 	if (*end != 0)
-	  einfo (_("%F%P: invalid --fixed-space value `%s'\''\n"), optarg);
+	  fatal (_("%P: invalid --fixed-space value `%s'\''\n"), optarg);
       }
       break;
 
@@ -788,7 +788,7 @@ PARSE_AND_LIST_ARGS_CASES='
 	char *end;
 	params.auto_overlay_reserved = strtoul (optarg, &end, 0);
 	if (*end != 0)
-	  einfo (_("%F%P: invalid --reserved-space value `%s'\''\n"), optarg);
+	  fatal (_("%P: invalid --reserved-space value `%s'\''\n"), optarg);
       }
       break;
 
@@ -797,7 +797,7 @@ PARSE_AND_LIST_ARGS_CASES='
 	char *end;
 	params.extra_stack_space = strtol (optarg, &end, 0);
 	if (*end != 0)
-	  einfo (_("%F%P: invalid --extra-stack-space value `%s'\''\n"), optarg);
+	  fatal (_("%P: invalid --extra-stack-space value `%s'\''\n"), optarg);
       }
       break;
 
diff --git a/ld/emultempl/tic6xdsbt.em b/ld/emultempl/tic6xdsbt.em
index 8140ef9c218..fc3e9a6184e 100644
--- a/ld/emultempl/tic6xdsbt.em
+++ b/ld/emultempl/tic6xdsbt.em
@@ -59,10 +59,8 @@ tic6x_after_open (void)
   if (is_tic6x_target ())
     {
       if (params.dsbt_index >= params.dsbt_size)
-	{
-	  einfo (_("%F%P: invalid --dsbt-index %d, outside DSBT size\n"),
-		 params.dsbt_index);
-	}
+	fatal (_("%P: invalid --dsbt-index %d, outside DSBT size\n"),
+	       params.dsbt_index);
       elf32_tic6x_setup (&link_info, &params);
     }
 
@@ -186,7 +184,7 @@ PARSE_AND_LIST_ARGS_CASES='
 	if (*end == 0
 	    && params.dsbt_index >= 0 && params.dsbt_index < 0x7fff)
 	  break;
-	einfo (_("%F%P: invalid --dsbt-index %s\n"), optarg);
+	fatal (_("%P: invalid --dsbt-index %s\n"), optarg);
       }
       break;
     case OPTION_DSBT_SIZE:
@@ -196,7 +194,7 @@ PARSE_AND_LIST_ARGS_CASES='
 	if (*end == 0
 	    && params.dsbt_size >= 0 && params.dsbt_size < 0x7fff)
 	  break;
-	einfo (_("%F%P: invalid --dsbt-size %s\n"), optarg);
+	fatal (_("%P: invalid --dsbt-size %s\n"), optarg);
       }
       break;
    case OPTION_NO_MERGE_EXIDX_ENTRIES:
diff --git a/ld/emultempl/ticoff.em b/ld/emultempl/ticoff.em
index fb6cf3a0c2e..bde5f22735b 100644
--- a/ld/emultempl/ticoff.em
+++ b/ld/emultempl/ticoff.em
@@ -88,9 +88,7 @@ gld${EMULATION_NAME}_handle_option (int optc)
 	  lang_add_output_format (buf, NULL, NULL, 0);
 	}
       else
-	{
-	  einfo (_("%F%P: invalid COFF format version %s\n"), optarg);
-	}
+	fatal (_("%P: invalid COFF format version %s\n"), optarg);
       break;
     }
   return false;
diff --git a/ld/emultempl/v850elf.em b/ld/emultempl/v850elf.em
index 7bcd45f3aee..49ad2cc8929 100644
--- a/ld/emultempl/v850elf.em
+++ b/ld/emultempl/v850elf.em
@@ -63,7 +63,7 @@ v850_create_output_section_statements (void)
 	 These will only be created if the output format is an arm format,
 	 hence we do not support linking and changing output formats at the
 	 same time.  Use a link followed by objcopy to change output formats.  */
-      einfo (_("%F%P: error: cannot change output format"
+      fatal (_("%P: error: cannot change output format"
 	       " whilst linking %s binaries\n"), "V850");
       return;
     }
diff --git a/ld/emultempl/vms.em b/ld/emultempl/vms.em
index b643233932f..b61b3d74d98 100644
--- a/ld/emultempl/vms.em
+++ b/ld/emultempl/vms.em
@@ -200,7 +200,7 @@ gld${EMULATION_NAME}_before_allocation (void)
   if (bed->elf_backend_late_size_sections
       && !bed->elf_backend_late_size_sections (link_info.output_bfd,
 					       &link_info))
-    einfo (_("%F%P: failed to set dynamic section sizes: %E\n"));
+    fatal (_("%P: failed to set dynamic section sizes: %E\n"));
 
   before_allocation_default ();
 }
diff --git a/ld/emultempl/xtensaelf.em b/ld/emultempl/xtensaelf.em
index 3508eb7f503..37edf3a0fdf 100644
--- a/ld/emultempl/xtensaelf.em
+++ b/ld/emultempl/xtensaelf.em
@@ -391,7 +391,7 @@ check_xtensa_info (bfd *abfd, asection *info_sec)
 
   data = xmalloc (info_sec->size);
   if (! bfd_get_section_contents (abfd, info_sec, data, 0, info_sec->size))
-    einfo (_("%F%P: %pB: cannot read contents of section %pA\n"), abfd, info_sec);
+    fatal (_("%P: %pB: cannot read contents of section %pA\n"), abfd, info_sec);
 
   if (info_sec->size > 24
       && info_sec->size >= 24 + bfd_get_32 (abfd, data + 4)
@@ -432,13 +432,13 @@ elf_xtensa_before_allocation (void)
   if (is_big_endian
       && link_info.output_bfd->xvec->byteorder == BFD_ENDIAN_LITTLE)
     {
-      einfo (_("%F%P: little endian output does not match "
+      fatal (_("%P: little endian output does not match "
 	       "Xtensa configuration\n"));
     }
   if (!is_big_endian
       && link_info.output_bfd->xvec->byteorder == BFD_ENDIAN_BIG)
     {
-      einfo (_("%F%P: big endian output does not match "
+      fatal (_("%P: big endian output does not match "
 	       "Xtensa configuration\n"));
     }
 
@@ -457,7 +457,7 @@ elf_xtensa_before_allocation (void)
 	 cannot go any further if there are any mismatches.  */
       if ((is_big_endian && f->the_bfd->xvec->byteorder == BFD_ENDIAN_LITTLE)
 	  || (!is_big_endian && f->the_bfd->xvec->byteorder == BFD_ENDIAN_BIG))
-	einfo (_("%F%P: cross-endian linking for %pB not supported\n"),
+	fatal (_("%P: cross-endian linking for %pB not supported\n"),
 	       f->the_bfd);
 
       if (! first_bfd)
@@ -488,7 +488,7 @@ elf_xtensa_before_allocation (void)
       info_sec = bfd_make_section_with_flags (first_bfd, ".xtensa.info",
 					      SEC_HAS_CONTENTS | SEC_READONLY);
       if (! info_sec)
-	einfo (_("%F%P: failed to create .xtensa.info section\n"));
+	fatal (_("%P: failed to create .xtensa.info section\n"));
     }
   if (info_sec)
     {
@@ -1227,7 +1227,7 @@ ld_build_required_section_dependence (lang_statement_union_type *s)
       lang_statement_union_type *l = iter_stack_current (&stack);
 
       if (l == NULL && link_info.non_contiguous_regions)
-	einfo (_("%F%P: Relaxation not supported with "
+	fatal (_("%P: Relaxation not supported with "
 		 "--enable-non-contiguous-regions.\n"));
 
       if (l->header.type == lang_input_section_enum)
diff --git a/ld/emultempl/z80.em b/ld/emultempl/z80.em
index ded04136f9e..555f602419e 100644
--- a/ld/emultempl/z80.em
+++ b/ld/emultempl/z80.em
@@ -48,7 +48,7 @@ z80_after_open (void)
       const bfd_arch_info_type *info;
       info = bfd_arch_get_compatible (link_info.output_bfd, abfd, false);
       if (info == NULL)
-	einfo (_("%F%P: %pB: Instruction sets of object files incompatible\n"),
+	fatal (_("%P: %pB: Instruction sets of object files incompatible\n"),
 	       abfd);
       else
         bfd_set_arch_info (link_info.output_bfd, info);
diff --git a/ld/ldcref.c b/ld/ldcref.c
index 632506a4aa8..572d4f4d0ac 100644
--- a/ld/ldcref.c
+++ b/ld/ldcref.c
@@ -514,7 +514,7 @@ check_local_sym_xref (lang_input_statement_type *statement)
     return;
 
   if (!bfd_generic_link_read_symbols (abfd))
-    einfo (_("%F%P: %pB: could not read symbols: %E\n"), abfd);
+    fatal (_("%P: %pB: could not read symbols: %E\n"), abfd);
 
   for (syms = bfd_get_outsymbols (abfd); *syms; ++syms)
     {
@@ -625,7 +625,7 @@ check_refs (const char *name,
      BFD might contain a prohibited cross reference.  */
 
   if (!bfd_generic_link_read_symbols (abfd))
-    einfo (_("%F%P: %pB: could not read symbols: %E\n"), abfd);
+    fatal (_("%P: %pB: could not read symbols: %E\n"), abfd);
 
   info.sym_name = name;
   info.global = global;
@@ -687,14 +687,14 @@ check_reloc_refs (bfd *abfd, asection *sec, void *iarg)
 
   relsize = bfd_get_reloc_upper_bound (abfd, sec);
   if (relsize < 0)
-    einfo (_("%F%P: %pB: could not read relocs: %E\n"), abfd);
+    fatal (_("%P: %pB: could not read relocs: %E\n"), abfd);
   if (relsize == 0)
     return;
 
   relpp = (arelent **) xmalloc (relsize);
   relcount = bfd_canonicalize_reloc (abfd, sec, relpp, info->asymbols);
   if (relcount < 0)
-    einfo (_("%F%P: %pB: could not read relocs: %E\n"), abfd);
+    fatal (_("%P: %pB: could not read relocs: %E\n"), abfd);
 
   p = relpp;
   pend = p + relcount;
diff --git a/ld/ldelf.c b/ld/ldelf.c
index 04045acbf3d..4201e19bd89 100644
--- a/ld/ldelf.c
+++ b/ld/ldelf.c
@@ -94,7 +94,7 @@ ldelf_after_parse (void)
       else if (!link_info.maxpagesize_is_set)
 	link_info.maxpagesize = link_info.commonpagesize;
       else
-	einfo (_("%F%P: common page size (0x%v) > maximum page size (0x%v)\n"),
+	fatal (_("%P: common page size (0x%v) > maximum page size (0x%v)\n"),
 	       link_info.commonpagesize, link_info.maxpagesize);
     }
 }
@@ -120,7 +120,7 @@ ldelf_load_symbols (lang_input_statement_type *entry)
 
   if (entry->flags.just_syms
       && (bfd_get_file_flags (entry->the_bfd) & DYNAMIC) != 0)
-    einfo (_("%F%P: %pB: --just-symbols may not be used on DSO\n"),
+    fatal (_("%P: %pB: --just-symbols may not be used on DSO\n"),
 	   entry->the_bfd);
 
   if (link_class == 0
@@ -320,7 +320,7 @@ ldelf_try_needed (struct dt_needed *needed, int force, int is_linux)
       struct bfd_link_needed_list *needs;
 
       if (! bfd_elf_get_bfd_needed_list (abfd, &needs))
-	einfo (_("%F%P: %pB: bfd_elf_get_bfd_needed_list failed: %E\n"), abfd);
+	fatal (_("%P: %pB: bfd_elf_get_bfd_needed_list failed: %E\n"), abfd);
 
       if (needs != NULL)
 	{
@@ -368,7 +368,7 @@ ldelf_try_needed (struct dt_needed *needed, int force, int is_linux)
      can only check that using stat.  */
 
   if (bfd_stat (abfd, &global_stat) != 0)
-    einfo (_("%F%P: %pB: bfd_stat failed: %E\n"), abfd);
+    fatal (_("%P: %pB: bfd_stat failed: %E\n"), abfd);
 
   /* First strip off everything before the last '/'.  */
   soname = lbasename (bfd_get_filename (abfd));
@@ -407,7 +407,7 @@ ldelf_try_needed (struct dt_needed *needed, int force, int is_linux)
 
   /* Add this file into the symbol table.  */
   if (! bfd_link_add_symbols (abfd, &link_info))
-    einfo (_("%F%P: %pB: error adding symbols: %E\n"), abfd);
+    fatal (_("%P: %pB: error adding symbols: %E\n"), abfd);
 
   return true;
 }
@@ -1202,7 +1202,7 @@ ldelf_handle_dt_needed (struct elf_link_hash_table *htab,
 	  && elf_dt_name (abfd) != NULL)
 	{
 	  if (bfd_elf_add_dt_needed_tag (abfd, &link_info) < 0)
-	    einfo (_("%F%P: failed to add DT_NEEDED dynamic tag\n"));
+	    fatal (_("%P: failed to add DT_NEEDED dynamic tag\n"));
 	}
 
   link_info.input_bfds_tail = save_input_bfd_tail;
@@ -1253,10 +1253,8 @@ ldelf_after_open (int use_libpath, int native, int is_linux, int is_freebsd,
 		     bfd_get_target (link_info.output_bfd));
 
       if (link_info.out_implib_bfd == NULL)
-	{
-	  einfo (_("%F%P: %s: can't open for writing: %E\n"),
-		 command_line.out_implib_filename);
-	}
+	fatal (_("%P: %s: can't open for writing: %E\n"),
+	       command_line.out_implib_filename);
     }
 
   if (ldelf_emit_note_gnu_build_id != NULL
@@ -1310,7 +1308,7 @@ ldelf_after_open (int use_libpath, int native, int is_linux, int is_freebsd,
 	  && (elf_tdata (abfd)->elf_header->e_type == ET_EXEC
 	      || (elf_tdata (abfd)->elf_header->e_type == ET_DYN
 		  && elf_tdata (abfd)->is_pie)))
-	einfo (_("%F%P: cannot use executable file '%pB' as input to a link\n"),
+	fatal (_("%P: cannot use executable file '%pB' as input to a link\n"),
 	       abfd);
     }
 
@@ -1364,7 +1362,7 @@ ldelf_after_open (int use_libpath, int native, int is_linux, int is_freebsd,
 		}
 	      else if (seen_type != type)
 		{
-		  einfo (_("%F%P: compact frame descriptions incompatible with"
+		  fatal (_("%P: compact frame descriptions incompatible with"
 			   " DWARF2 .eh_frame from %pB\n"),
 			 type == DWARF2_EH_HDR ? abfd : elfbfd);
 		  break;
@@ -1406,7 +1404,7 @@ ldelf_after_open (int use_libpath, int native, int is_linux, int is_freebsd,
 
   if (link_info.eh_frame_hdr_type == COMPACT_EH_HDR)
     if (!bfd_elf_parse_eh_frame_entries (NULL, &link_info))
-      einfo (_("%F%P: failed to parse EH frame entries\n"));
+      fatal (_("%P: failed to parse EH frame entries\n"));
 
   ldelf_handle_dt_needed (htab, use_libpath, native, is_linux,
 			  is_freebsd, elfsize, prefix);
@@ -1663,7 +1661,7 @@ ldelf_find_exp_assignment (etree_type *exp)
 					       &link_info,
 					       exp->assign.dst, provide,
 					       exp->assign.hidden))
-	    einfo (_("%F%P: failed to record assignment to %s: %E\n"),
+	    fatal (_("%P: failed to record assignment to %s: %E\n"),
 		   exp->assign.dst);
 	}
       ldelf_find_exp_assignment (exp->assign.src);
@@ -1841,7 +1839,7 @@ ldelf_before_allocation (char *audit, char *depaudit,
 	  command_line.filter_shlib, audit, depaudit,
 	  (const char * const *) command_line.auxiliary_filters,
 	  &link_info, &sinterp)))
-    einfo (_("%F%P: failed to set dynamic section sizes: %E\n"));
+    fatal (_("%P: failed to set dynamic section sizes: %E\n"));
 
   if (sinterp != NULL)
     {
@@ -1878,8 +1876,8 @@ ldelf_before_allocation (char *audit, char *depaudit,
 	msg = (char *) xmalloc ((size_t) (sz + 1));
 	if (! bfd_get_section_contents (is->the_bfd, s,	msg,
 					(file_ptr) 0, sz))
-	  einfo (_("%F%P: %pB: can't read contents of section .gnu.warning: %E\n"),
-		 is->the_bfd);
+	  fatal (_("%P: %pB: can't read contents of section %pA: %E\n"),
+		 is->the_bfd, s);
 	msg[sz] = '\0';
 	(*link_info.callbacks->warning) (&link_info, msg,
 					 (const char *) NULL, is->the_bfd,
@@ -1906,7 +1904,7 @@ ldelf_before_allocation (char *audit, char *depaudit,
   before_allocation_default ();
 
   if (!bfd_elf_size_dynsym_hash_dynstr (link_info.output_bfd, &link_info))
-    einfo (_("%F%P: failed to set dynamic section sizes: %E\n"));
+    fatal (_("%P: failed to set dynamic section sizes: %E\n"));
 
   if (ehdr_start != NULL)
     {
diff --git a/ld/ldelfgen.c b/ld/ldelfgen.c
index d3448546f3a..1b1e49ceea2 100644
--- a/ld/ldelfgen.c
+++ b/ld/ldelfgen.c
@@ -282,7 +282,7 @@ ldelf_map_segments (bool need_layout)
 		  if (os_info->ordered != os_info->count
 		      && bfd_link_relocatable (&link_info))
 		    {
-		      einfo (_("%F%P: "
+		      fatal (_("%P: "
 			       "%pA has both ordered and unordered sections\n"),
 			     os->bfd_section);
 		      return;
@@ -307,7 +307,7 @@ ldelf_map_segments (bool need_layout)
 	  if (!_bfd_elf_map_sections_to_segments (link_info.output_bfd,
 						  &link_info,
 						  &need_layout))
-	    einfo (_("%F%P: map sections to segments failed: %E\n"));
+	    fatal (_("%P: map sections to segments failed: %E\n"));
 
 	  if (phdr_size != elf_program_header_size (link_info.output_bfd))
 	    {
@@ -327,7 +327,7 @@ ldelf_map_segments (bool need_layout)
   while (need_layout && --tries);
 
   if (tries == 0)
-    einfo (_("%F%P: looping in map_segments\n"));
+    fatal (_("%P: looping in map_segments\n"));
 
   if (bfd_get_flavour (link_info.output_bfd) == bfd_target_elf_flavour
       && lang_phdr_list == NULL)
@@ -337,9 +337,8 @@ ldelf_map_segments (bool need_layout)
       const struct elf_backend_data *bed
 	= get_elf_backend_data (link_info.output_bfd);
       if (bed->elf_backend_strip_zero_sized_dynamic_sections
-	  && !bed->elf_backend_strip_zero_sized_dynamic_sections
-		(&link_info))
-	  einfo (_("%F%P: failed to strip zero-sized dynamic sections\n"));
+	  && !bed->elf_backend_strip_zero_sized_dynamic_sections (&link_info))
+	fatal (_("%P: failed to strip zero-sized dynamic sections\n"));
     }
 }
 
@@ -417,7 +416,7 @@ ldelf_acquire_strings_for_ctf
     {
       if (ctf_link_add_strtab (ctf_output, ldelf_ctf_strtab_iter_cb,
 			       &args) < 0)
-	einfo (_("%F%P: warning: CTF strtab association failed; strings will "
+	fatal (_("%P: warning: CTF strtab association failed; strings will "
 		 "not be shared: %s\n"),
 	       ctf_errmsg (ctf_errno (ctf_output)));
     }
@@ -444,7 +443,7 @@ ldelf_new_dynsym_for_ctf (struct ctf_dict *ctf_output, int symidx,
       lsym.st_value = sym->st_value;
       if (ctf_link_add_linker_symbol (ctf_output, &lsym) < 0)
 	{
-	  einfo (_("%F%P: warning: CTF symbol addition failed; CTF will "
+	  fatal (_("%P: warning: CTF symbol addition failed; CTF will "
 		   "not be tied to symbols: %s\n"),
 		 ctf_errmsg (ctf_errno (ctf_output)));
 	}
@@ -454,7 +453,7 @@ ldelf_new_dynsym_for_ctf (struct ctf_dict *ctf_output, int symidx,
       /* Shuffle all the symbols.  */
 
       if (ctf_link_shuffle_syms (ctf_output) < 0)
-	einfo (_("%F%P: warning: CTF symbol shuffling failed; CTF will "
+	fatal (_("%P: warning: CTF symbol shuffling failed; CTF will "
 		 "not be tied to symbols: %s\n"),
 	       ctf_errmsg (ctf_errno (ctf_output)));
     }
diff --git a/ld/ldemul.c b/ld/ldemul.c
index 218abb84b9b..b56b049208c 100644
--- a/ld/ldemul.c
+++ b/ld/ldemul.c
@@ -343,7 +343,7 @@ ldemul_choose_mode (char *target)
   einfo (_("%P: unrecognised emulation mode: %s\n"), target);
   einfo (_("Supported emulations: "));
   ldemul_list_emulations (stderr);
-  einfo ("%F\n");
+  fatal ("\n");
 }
 
 void
diff --git a/ld/ldexp.c b/ld/ldexp.c
index 3c8ab2d3589..45dffbc6578 100644
--- a/ld/ldexp.c
+++ b/ld/ldexp.c
@@ -282,7 +282,7 @@ definedness_newfunc (struct bfd_hash_entry *entry,
       bfd_hash_allocate (table, sizeof (struct definedness_hash_entry));
 
   if (ret == NULL)
-    einfo (_("%F%P: bfd_hash_allocate failed creating symbol %s\n"), name);
+    fatal (_("%P: bfd_hash_allocate failed creating symbol %s\n"), name);
 
   ret->by_object = 0;
   ret->iteration = 0;
@@ -313,7 +313,7 @@ update_definedness (const char *name, struct bfd_link_hash_entry *h)
     bfd_hash_lookup (&definedness_table, name, true, false);
 
   if (defentry == NULL)
-    einfo (_("%F%P: bfd_hash_lookup failed creating symbol %s\n"), name);
+    fatal (_("%P: bfd_hash_lookup failed creating symbol %s\n"), name);
 
   /* If the symbol was already defined, and not by a script, then it
      must be defined by an object file or by the linker target code.  */
@@ -638,7 +638,7 @@ fold_binary (etree_type *tree)
 	    expld.result.value = ((bfd_signed_vma) lhs.value
 				  % (bfd_signed_vma) expld.result.value);
 	  else if (expld.phase != lang_mark_phase_enum)
-	    einfo (_("%F%P:%pS %% by zero\n"), tree->binary.rhs);
+	    fatal (_("%P:%pS %% by zero\n"), tree->binary.rhs);
 	  arith_result_section (&lhs);
 	  break;
 
@@ -647,7 +647,7 @@ fold_binary (etree_type *tree)
 	    expld.result.value = ((bfd_signed_vma) lhs.value
 				  / (bfd_signed_vma) expld.result.value);
 	  else if (expld.phase != lang_mark_phase_enum)
-	    einfo (_("%F%P:%pS / by zero\n"), tree->binary.rhs);
+	    fatal (_("%P:%pS / by zero\n"), tree->binary.rhs);
 	  arith_result_section (&lhs);
 	  break;
 
@@ -761,7 +761,7 @@ fold_name (etree_type *tree)
 	  if (!h)
 	    {
 	      if (expld.phase != lang_first_phase_enum)
-		einfo (_("%F%P: bfd_link_hash_lookup failed: %E\n"));
+		fatal (_("%P: bfd_link_hash_lookup failed: %E\n"));
 	    }
 	  else if (h->type == bfd_link_hash_defined
 		   || h->type == bfd_link_hash_defweak)
@@ -789,7 +789,7 @@ fold_name (etree_type *tree)
 	  else if (expld.phase == lang_final_phase_enum
 		   || (expld.phase != lang_mark_phase_enum
 		       && expld.assigning_to_dot))
-	    einfo (_("%F%P:%pS: undefined symbol `%s'"
+	    fatal (_("%P:%pS: undefined symbol `%s'"
 		     " referenced in expression\n"),
 		   tree, tree->name.name);
 	  else if (h->type == bfd_link_hash_new)
@@ -827,7 +827,7 @@ fold_name (etree_type *tree)
 	  if (os == NULL)
 	    {
 	      if (expld.phase == lang_final_phase_enum)
-		einfo (_("%F%P:%pS: undefined section `%s'"
+		fatal (_("%P:%pS: undefined section `%s'"
 			 " referenced in expression\n"),
 		       tree, tree->name.name);
 	    }
@@ -845,7 +845,7 @@ fold_name (etree_type *tree)
 	  if (os == NULL)
 	    {
 	      if (expld.phase == lang_final_phase_enum)
-		einfo (_("%F%P:%pS: undefined section `%s'"
+		fatal (_("%P:%pS: undefined section `%s'"
 			 " referenced in expression\n"),
 		       tree, tree->name.name);
 	    }
@@ -873,7 +873,7 @@ fold_name (etree_type *tree)
 	  if (os == NULL)
 	    {
 	      if (expld.phase == lang_final_phase_enum)
-		einfo (_("%F%P:%pS: undefined section `%s'"
+		fatal (_("%P:%pS: undefined section `%s'"
 			 " referenced in expression\n"),
 		       tree, tree->name.name);
 	      new_number (0);
@@ -912,7 +912,7 @@ fold_name (etree_type *tree)
 	if (mem != NULL)
 	  new_number (mem->length);
 	else
-	  einfo (_("%F%P:%pS: undefined MEMORY region `%s'"
+	  fatal (_("%P:%pS: undefined MEMORY region `%s'"
 		   " referenced in expression\n"),
 		 tree, tree->name.name);
       }
@@ -926,7 +926,7 @@ fold_name (etree_type *tree)
 	if (mem != NULL)
 	  new_rel_from_abs (mem->origin);
 	else
-	  einfo (_("%F%P:%pS: undefined MEMORY region `%s'"
+	  fatal (_("%P:%pS: undefined MEMORY region `%s'"
 		   " referenced in expression\n"),
 		 tree, tree->name.name);
       }
@@ -938,7 +938,7 @@ fold_name (etree_type *tree)
       else if (strcmp (tree->name.name, "COMMONPAGESIZE") == 0)
 	new_number (link_info.commonpagesize);
       else
-	einfo (_("%F%P:%pS: unknown constant `%s' referenced in expression\n"),
+	fatal (_("%P:%pS: unknown constant `%s' referenced in expression\n"),
 	       tree, tree->name.name);
       break;
 
@@ -1086,7 +1086,7 @@ exp_fold_tree_1 (etree_type *tree)
       if (tree->assign.dst[0] == '.' && tree->assign.dst[1] == 0)
 	{
 	  if (tree->type.node_class != etree_assign)
-	    einfo (_("%F%P:%pS can not PROVIDE assignment to"
+	    fatal (_("%P:%pS can not PROVIDE assignment to"
 		     " location counter\n"), tree);
 	  if (expld.phase != lang_first_phase_enum)
 	    {
@@ -1119,11 +1119,11 @@ exp_fold_tree_1 (etree_type *tree)
 		  || expld.section == bfd_und_section_ptr)
 		{
 		  if (expld.phase != lang_mark_phase_enum)
-		    einfo (_("%F%P:%pS invalid assignment to"
+		    fatal (_("%P:%pS invalid assignment to"
 			     " location counter\n"), tree);
 		}
 	      else if (expld.dotp == NULL)
-		einfo (_("%F%P:%pS assignment to location counter"
+		fatal (_("%P:%pS assignment to location counter"
 			 " invalid outside of SECTIONS\n"), tree);
 
 	      /* After allocation, assignment to dot should not be
@@ -1142,7 +1142,7 @@ exp_fold_tree_1 (etree_type *tree)
 		    nextdot += expld.section->vma;
 		  if (nextdot < expld.dot
 		      && expld.section != bfd_abs_section_ptr)
-		    einfo (_("%F%P:%pS cannot move location counter backwards"
+		    fatal (_("%P:%pS cannot move location counter backwards"
 			     " (from %V to %V)\n"),
 			   tree, expld.dot, nextdot);
 		  else
@@ -1202,7 +1202,7 @@ exp_fold_tree_1 (etree_type *tree)
 		  h = bfd_link_hash_lookup (link_info.hash, tree->assign.dst,
 					    true, false, true);
 		  if (h == NULL)
-		    einfo (_("%F%P:%s: hash creation failed\n"),
+		    fatal (_("%P:%s: hash creation failed\n"),
 			   tree->assign.dst);
 		}
 
@@ -1578,7 +1578,7 @@ exp_get_vma (etree_type *tree, lang_output_section_statement_type *os,
       if (expld.result.valid_p)
 	return expld.result.value;
       else if (name != NULL && expld.phase != lang_mark_phase_enum)
-	einfo (_("%F%P:%pS: nonconstant expression for %s\n"),
+	fatal (_("%P:%pS: nonconstant expression for %s\n"),
 	       tree, name);
     }
   return def;
@@ -1621,7 +1621,7 @@ exp_get_fill (etree_type *tree, fill_type *def, char *name)
   if (!expld.result.valid_p)
     {
       if (name != NULL && expld.phase != lang_mark_phase_enum)
-	einfo (_("%F%P:%pS: nonconstant expression for %s\n"),
+	fatal (_("%P:%pS: nonconstant expression for %s\n"),
 	       tree, name);
       return def;
     }
@@ -1681,7 +1681,7 @@ exp_get_abs_int (etree_type *tree, int def, char *name)
 	}
       else if (name != NULL && expld.phase != lang_mark_phase_enum)
 	{
-	  einfo (_("%F%P:%pS: nonconstant expression for %s\n"),
+	  fatal (_("%P:%pS: nonconstant expression for %s\n"),
 		 tree, name);
 	}
     }
@@ -1707,7 +1707,7 @@ ldexp_init (void)
 			      definedness_newfunc,
 			      sizeof (struct definedness_hash_entry),
 			      13))
-    einfo (_("%F%P: can not create hash table: %E\n"));
+    fatal (_("%P: can not create hash table: %E\n"));
 }
 
 /* Convert absolute symbols defined by a script from "dot" (also
diff --git a/ld/ldfile.c b/ld/ldfile.c
index f1107a1b7d7..5d61928299b 100644
--- a/ld/ldfile.c
+++ b/ld/ldfile.c
@@ -183,7 +183,7 @@ ldfile_add_remap_file (const char * file)
 
       if (*p == '\0')
 	{
-	  einfo ("%F%P: malformed remap file entry: %s\n", line);
+	  fatal ("%P: malformed remap file entry: %s\n", line);
 	  continue;
 	}
 
@@ -195,7 +195,7 @@ ldfile_add_remap_file (const char * file)
 
       if (*p == '\0')
 	{
-	  einfo ("%F%P: malformed remap file entry: %s\n", line);
+	  fatal ("%P: malformed remap file entry: %s\n", line);
 	  continue;
 	}
 
@@ -348,7 +348,7 @@ ldfile_try_open_bfd (const char *attempt,
   if (entry->the_bfd == NULL)
     {
       if (bfd_get_error () == bfd_error_invalid_target)
-	einfo (_("%F%P: invalid BFD target `%s'\n"), entry->target);
+	fatal (_("%P: invalid BFD target `%s'\n"), entry->target);
       return false;
     }
 
@@ -491,7 +491,7 @@ ldfile_try_open_bfd (const char *attempt,
 
 	  if (!entry->flags.dynamic && (entry->the_bfd->flags & DYNAMIC) != 0)
 	    {
-	      einfo (_("%F%P: attempted static link of dynamic object `%s'\n"),
+	      fatal (_("%P: attempted static link of dynamic object `%s'\n"),
 		     attempt);
 	      bfd_close (entry->the_bfd);
 	      entry->the_bfd = NULL;
@@ -889,7 +889,7 @@ ldfile_open_command_file_1 (const char *name, enum script_open_style open_how)
       if ((open_how != script_nonT || script->open_how != script_nonT)
 	  && strcmp (name, script->name) == 0)
 	{
-	  einfo (_("%F%P: error: linker script file '%s'"
+	  fatal (_("%P: error: linker script file '%s'"
 		   " appears multiple times\n"), name);
 	  return;
 	}
@@ -911,7 +911,7 @@ ldfile_open_command_file_1 (const char *name, enum script_open_style open_how)
   if (ldlex_input_stack == NULL)
     {
       bfd_set_error (bfd_error_system_call);
-      einfo (_("%F%P: cannot open linker script file %s: %E\n"), name);
+      fatal (_("%P: cannot open linker script file %s: %E\n"), name);
       return;
     }
 
@@ -982,5 +982,5 @@ ldfile_set_output_arch (const char *string, enum bfd_architecture defarch)
   else if (defarch != bfd_arch_unknown)
     ldfile_output_architecture = defarch;
   else
-    einfo (_("%F%P: cannot represent machine `%s'\n"), string);
+    fatal (_("%P: cannot represent machine `%s'\n"), string);
 }
diff --git a/ld/ldgram.y b/ld/ldgram.y
index 07c19ba8692..190111294da 100644
--- a/ld/ldgram.y
+++ b/ld/ldgram.y
@@ -210,7 +210,7 @@ mri_script_command:
 		CHIP  exp
 	|	CHIP  exp ',' exp
 	|	NAME	{
-			einfo(_("%F%P: unrecognised keyword in MRI style script '%s'\n"),$1);
+			fatal (_("%P: unrecognised keyword in MRI style script '%s'\n"), $1);
 			}
 	|	LIST	{
 			config.map_filename = "-";
@@ -1581,7 +1581,7 @@ yyerror (const char *arg)
     einfo (_("%P:%s: file format not recognized; treating as linker script\n"),
 	   ldlex_filename ());
   if (error_index > 0 && error_index < ERROR_NAME_MAX)
-    einfo (_("%F%P:%pS: %s in %s\n"), NULL, arg, error_names[error_index - 1]);
+    fatal (_("%P:%pS: %s in %s\n"), NULL, arg, error_names[error_index - 1]);
   else
-    einfo ("%F%P:%pS: %s\n", NULL, arg);
+    fatal ("%P:%pS: %s\n", NULL, arg);
 }
diff --git a/ld/ldlang.c b/ld/ldlang.c
index 1d2fe3164e7..a4ee1bc0730 100644
--- a/ld/ldlang.c
+++ b/ld/ldlang.c
@@ -1341,7 +1341,7 @@ output_section_statement_table_init (void)
 			      output_section_statement_newfunc,
 			      sizeof (struct out_section_hash_entry),
 			      61))
-    einfo (_("%F%P: can not create hash table: %E\n"));
+    fatal (_("%P: can not create hash table: %E\n"));
 }
 
 static void
@@ -1469,7 +1469,7 @@ lang_memory_region_alias (const char *alias, const char *region_name)
      the default memory region.  */
   if (strcmp (region_name, DEFAULT_MEMORY_REGION) == 0
       || strcmp (alias, DEFAULT_MEMORY_REGION) == 0)
-    einfo (_("%F%P:%pS: error: alias for default memory region\n"), NULL);
+    fatal (_("%P:%pS: error: alias for default memory region\n"), NULL);
 
   /* Look for the target region and check if the alias is not already
      in use.  */
@@ -1480,14 +1480,14 @@ lang_memory_region_alias (const char *alias, const char *region_name)
 	if (region == NULL && strcmp (n->name, region_name) == 0)
 	  region = r;
 	if (strcmp (n->name, alias) == 0)
-	  einfo (_("%F%P:%pS: error: redefinition of memory region "
+	  fatal (_("%P:%pS: error: redefinition of memory region "
 		   "alias `%s'\n"),
 		 NULL, alias);
       }
 
   /* Check if the target region exists.  */
   if (region == NULL)
-    einfo (_("%F%P:%pS: error: memory region `%s' "
+    fatal (_("%P:%pS: error: memory region `%s' "
 	     "for alias `%s' does not exist\n"),
 	   NULL, region_name, alias);
 
@@ -1548,7 +1548,7 @@ lang_output_section_statement_lookup (const char *name,
   if (entry == NULL)
     {
       if (create)
-	einfo (_("%F%P: failed creating section `%s': %E\n"), name);
+	fatal (_("%P: failed creating section `%s': %E\n"), name);
       return NULL;
     }
 
@@ -1591,7 +1591,7 @@ lang_output_section_statement_lookup (const char *name,
 						name);
       if (entry == NULL)
 	{
-	  einfo (_("%F%P: failed creating section `%s': %E\n"), name);
+	  fatal (_("%P: failed creating section `%s': %E\n"), name);
 	  return NULL;
 	}
       entry->root = last_ent->root;
@@ -2451,7 +2451,7 @@ static void
 init_os (lang_output_section_statement_type *s, flagword flags)
 {
   if (strcmp (s->name, DISCARD_SECTION_NAME) == 0)
-    einfo (_("%F%P: illegal use of `%s' section\n"), DISCARD_SECTION_NAME);
+    fatal (_("%P: illegal use of `%s' section\n"), DISCARD_SECTION_NAME);
 
   if (!s->dup_output)
     s->bfd_section = bfd_get_section_by_name (link_info.output_bfd, s->name);
@@ -2460,7 +2460,7 @@ init_os (lang_output_section_statement_type *s, flagword flags)
 							 s->name, flags);
   if (s->bfd_section == NULL)
     {
-      einfo (_("%F%P: output format %s cannot represent section"
+      fatal (_("%P: output format %s cannot represent section"
 	       " called %s: %E\n"),
 	     link_info.output_bfd->xvec->name, s->name);
     }
@@ -3050,11 +3050,11 @@ load_symbols (lang_input_statement_type *entry,
 	  for (p = matching; *p != NULL; p++)
 	    einfo (" %s", *p);
 	  free (matching);
-	  einfo ("%F\n");
+	  fatal ("\n");
 	}
       else if (err != bfd_error_file_not_recognized
 	       || place == NULL)
-	einfo (_("%F%P: %pB: file not recognized: %E\n"), entry->the_bfd);
+	fatal (_("%P: %pB: file not recognized: %E\n"), entry->the_bfd);
 
       bfd_close (entry->the_bfd);
       entry->the_bfd = NULL;
@@ -3127,7 +3127,7 @@ load_symbols (lang_input_statement_type *entry,
 
 	      if (!bfd_check_format (member, bfd_object))
 		{
-		  einfo (_("%F%P: %pB: member %pB in archive is not an object\n"),
+		  fatal (_("%P: %pB: member %pB in archive is not an object\n"),
 			 entry->the_bfd, member);
 		  loaded = false;
 		}
@@ -3142,7 +3142,7 @@ load_symbols (lang_input_statement_type *entry,
 		 substitute BFD for us.  */
 	      if (!bfd_link_add_symbols (subsbfd, &link_info))
 		{
-		  einfo (_("%F%P: %pB: error adding symbols: %E\n"), member);
+		  fatal (_("%P: %pB: error adding symbols: %E\n"), member);
 		  loaded = false;
 		}
 	    }
@@ -3156,7 +3156,7 @@ load_symbols (lang_input_statement_type *entry,
   if (bfd_link_add_symbols (entry->the_bfd, &link_info))
     entry->flags.loaded = true;
   else
-    einfo (_("%F%P: %pB: error adding symbols: %E\n"), entry->the_bfd);
+    fatal (_("%P: %pB: error adding symbols: %E\n"), entry->the_bfd);
 
   return entry->flags.loaded;
 }
@@ -3397,7 +3397,7 @@ open_output (const char *name)
       {
 	char *in = lrealpath (f->local_sym_name);
 	if (filename_cmp (in, out) == 0)
-	  einfo (_("%F%P: input file '%s' is the same as output file\n"),
+	  fatal (_("%P: input file '%s' is the same as output file\n"),
 		 f->filename);
 	free (in);
       }
@@ -3459,23 +3459,23 @@ open_output (const char *name)
   if (link_info.output_bfd == NULL)
     {
       if (bfd_get_error () == bfd_error_invalid_target)
-	einfo (_("%F%P: target %s not found\n"), output_target);
+	fatal (_("%P: target %s not found\n"), output_target);
 
-      einfo (_("%F%P: cannot open output file %s: %E\n"), name);
+      fatal (_("%P: cannot open output file %s: %E\n"), name);
     }
 
   delete_output_file_on_failure = true;
 
   if (!bfd_set_format (link_info.output_bfd, bfd_object))
-    einfo (_("%F%P: %s: can not make object file: %E\n"), name);
+    fatal (_("%P: %s: can not make object file: %E\n"), name);
   if (!bfd_set_arch_mach (link_info.output_bfd,
-			   ldfile_output_architecture,
-			   ldfile_output_machine))
-    einfo (_("%F%P: %s: can not set architecture: %E\n"), name);
+			  ldfile_output_architecture,
+			  ldfile_output_machine))
+    fatal (_("%P: %s: can not set architecture: %E\n"), name);
 
   link_info.hash = bfd_link_hash_table_create (link_info.output_bfd);
   if (link_info.hash == NULL)
-    einfo (_("%F%P: can not create hash table: %E\n"));
+    fatal (_("%P: can not create hash table: %E\n"));
 
   bfd_set_gp_size (link_info.output_bfd, g_switch_value);
 }
@@ -3689,7 +3689,7 @@ open_input_bfds (lang_statement_union_type *s,
 
   /* Exit if any of the files were missing.  */
   if (input_flags.missing_file)
-    einfo ("%F");
+    fatal ("");
 }
 
 #ifdef ENABLE_LIBCTF
@@ -4000,7 +4000,7 @@ insert_undefined (const char *name)
 
   h = bfd_link_hash_lookup (link_info.hash, name, true, false, true);
   if (h == NULL)
-    einfo (_("%F%P: bfd_link_hash_lookup failed: %E\n"));
+    fatal (_("%P: bfd_link_hash_lookup failed: %E\n"));
   if (h->type == bfd_link_hash_new)
     {
       h->type = bfd_link_hash_undefined;
@@ -4286,7 +4286,7 @@ map_input_to_output_sections
 		  else if (strcmp (name, "SHT_PREINIT_ARRAY") == 0)
 		    type = SHT_PREINIT_ARRAY;
 		  else
-		    einfo (_ ("%F%P: invalid type for output section `%s'\n"),
+		    fatal (_ ("%P: invalid type for output section `%s'\n"),
 			   os->name);
 		}
 	     else
@@ -4295,7 +4295,7 @@ map_input_to_output_sections
 		 if (expld.result.valid_p)
 		   type = expld.result.value;
 		 else
-		   einfo (_ ("%F%P: invalid type for output section `%s'\n"),
+		   fatal (_ ("%P: invalid type for output section `%s'\n"),
 			  os->name);
 	       }
 	      break;
@@ -4444,7 +4444,7 @@ process_insert_statements (lang_statement_union_type **start)
 	    }
 	  if (where == NULL)
 	    {
-	      einfo (_("%F%P: %s not found for insert\n"), i->where);
+	      fatal (_("%P: %s not found for insert\n"), i->where);
 	      return;
 	    }
 
@@ -5529,12 +5529,12 @@ size_input_section
 	      if (dot + TO_ADDR (i->size) > end)
 		{
 		  if (i->flags & SEC_LINKER_CREATED)
-		    einfo (_("%F%P: Output section `%pA' not large enough for "
+		    fatal (_("%P: Output section `%pA' not large enough for "
 			     "the linker-created stubs section `%pA'.\n"),
 			   i->output_section, i);
 
 		  if (i->rawsize && i->rawsize != i->size)
-		    einfo (_("%F%P: Relaxation not supported with "
+		    fatal (_("%P: Relaxation not supported with "
 			     "--enable-non-contiguous-regions (section `%pA' "
 			     "would overflow `%pA' after it changed size).\n"),
 			   i, i->output_section);
@@ -5890,7 +5890,7 @@ lang_size_sections_1
 		      dot += expld.result.section->vma;
 		  }
 		else if (expld.phase != lang_mark_phase_enum)
-		  einfo (_("%F%P:%pS: non constant or forward reference"
+		  fatal (_("%P:%pS: non constant or forward reference"
 			   " address expression for section %s\n"),
 			 os->addr_tree, os->name);
 	      }
@@ -5973,7 +5973,7 @@ lang_size_sections_1
 			   overridden by the using the --no-check-sections
 			   switch.  */
 			if (command_line.check_section_addresses)
-			  einfo (_("%F%P: error: no memory region specified"
+			  fatal (_("%P: error: no memory region specified"
 				   " for loadable section `%s'\n"),
 				 bfd_section_name (os->bfd_section));
 			else
@@ -6280,7 +6280,7 @@ lang_size_sections_1
 		bool again;
 
 		if (!bfd_relax_section (i->owner, i, &link_info, &again))
-		  einfo (_("%F%P: can't relax section: %E\n"));
+		  fatal (_("%P: can't relax section: %E\n"));
 		if (again)
 		  *relax = true;
 	      }
@@ -6689,7 +6689,7 @@ lang_do_assignments_1 (lang_statement_union_type *s,
 		s->data_statement.value += expld.result.section->vma;
 	    }
 	  else if (expld.phase == lang_final_phase_enum)
-	    einfo (_("%F%P: invalid data statement\n"));
+	    fatal (_("%P: invalid data statement\n"));
 	  {
 	    unsigned int size;
 	    switch (s->data_statement.type)
@@ -6722,7 +6722,7 @@ lang_do_assignments_1 (lang_statement_union_type *s,
 	  if (expld.result.valid_p)
 	    s->reloc_statement.addend_value = expld.result.value;
 	  else if (expld.phase == lang_final_phase_enum)
-	    einfo (_("%F%P: invalid reloc statement\n"));
+	    fatal (_("%P: invalid reloc statement\n"));
 	  dot += TO_ADDR (bfd_get_reloc_size (s->reloc_statement.howto));
 	  break;
 
@@ -7140,7 +7140,7 @@ lang_end (void)
 	    break;
 	}
       if (!sym)
-	einfo (_("%F%P: --gc-sections requires a defined symbol root "
+	fatal (_("%P: --gc-sections requires a defined symbol root "
 		 "specified by -e or -u\n"));
     }
 
@@ -7165,7 +7165,7 @@ lang_end (void)
 	     + bfd_section_vma (h->u.def.section->output_section)
 	     + h->u.def.section->output_offset);
       if (!bfd_set_start_address (link_info.output_bfd, val))
-	einfo (_("%F%P: %s: can't set start address\n"), entry_symbol.name);
+	fatal (_("%P: %s: can't set start address\n"), entry_symbol.name);
     }
   else
     {
@@ -7178,7 +7178,7 @@ lang_end (void)
       if (*send == '\0')
 	{
 	  if (!bfd_set_start_address (link_info.output_bfd, val))
-	    einfo (_("%F%P: can't set start address\n"));
+	    fatal (_("%P: can't set start address\n"));
 	}
       /* BZ 2004952: Only use the start of the entry section for executables.  */
       else if bfd_link_executable (&link_info)
@@ -7197,7 +7197,7 @@ lang_end (void)
 		       bfd_section_vma (ts));
 	      if (!bfd_set_start_address (link_info.output_bfd,
 					  bfd_section_vma (ts)))
-		einfo (_("%F%P: can't set start address\n"));
+		fatal (_("%P: can't set start address\n"));
 	    }
 	  else
 	    {
@@ -7266,11 +7266,10 @@ lang_check (void)
 		  != bfd_get_flavour (link_info.output_bfd)))
 	  && (bfd_get_file_flags (input_bfd) & HAS_RELOC) != 0)
 	{
-	  einfo (_("%F%P: relocatable linking with relocations from"
+	  fatal (_("%P: relocatable linking with relocations from"
 		   " format %s (%pB) to format %s (%pB) is not supported\n"),
 		 bfd_get_target (input_bfd), input_bfd,
 		 bfd_get_target (link_info.output_bfd), link_info.output_bfd);
-	  /* einfo with %F exits.  */
 	}
 
       if (compatible == NULL)
@@ -7371,7 +7370,7 @@ lang_one_common (struct bfd_link_hash_entry *h, void *info)
 
   section = h->u.c.p->section;
   if (!bfd_define_common_symbol (link_info.output_bfd, &link_info, h))
-    einfo (_("%F%P: could not define common symbol `%pT': %E\n"),
+    fatal (_("%P: could not define common symbol `%pT': %E\n"),
 	   h->root.string);
 
   if (config.map_file != NULL)
@@ -7549,7 +7548,7 @@ lang_set_flags (lang_memory_region_type *ptr, const char *flags, int invert)
 	  break;
 
 	default:
-	  einfo (_("%F%P: invalid character %c (%d) in flags\n"),
+	  fatal (_("%P: invalid character %c (%d) in flags\n"),
 		 *flags, *flags);
 	  break;
 	}
@@ -7643,7 +7642,7 @@ lang_enter_output_section_statement (const char *output_section_statement_name,
 					     constraint,
 					     in_section_ordering ? 0 : 2);
   if (os == NULL) /* && in_section_ordering */
-    einfo (_("%F%P:%pS: error: output section '%s' must already exist\n"),
+    fatal (_("%P:%pS: error: output section '%s' must already exist\n"),
 	   NULL, output_section_statement_name);
   current_section = os;
 
@@ -7667,7 +7666,7 @@ lang_enter_output_section_statement (const char *output_section_statement_name,
 
   os->align_lma_with_input = align_with_input == ALIGN_WITH_INPUT;
   if (os->align_lma_with_input && align != NULL)
-    einfo (_("%F%P:%pS: error: align with input and explicit align specified\n"),
+    fatal (_("%P:%pS: error: align with input and explicit align specified\n"),
 	   NULL);
 
   os->subsection_alignment = subalign;
@@ -8204,7 +8203,7 @@ lang_process (void)
   lang_place_undefineds ();
 
   if (!bfd_section_already_linked_table_init ())
-    einfo (_("%F%P: can not create hash table: %E\n"));
+    fatal (_("%P: can not create hash table: %E\n"));
 
   /* A first pass through the memory regions ensures that if any region
      references a symbol for its origin or length then this symbol will be
@@ -8242,7 +8241,7 @@ lang_process (void)
       files = file_chain;
       inputfiles = input_file_chain;
       if (plugin_call_all_symbols_read ())
-	einfo (_("%F%P: %s: plugin reported error after all symbols read\n"),
+	fatal (_("%P: %s: plugin reported error after all symbols read\n"),
 	       plugin_error_plugin ());
       link_info.lto_all_symbols_read = true;
       /* Open any newly added files, updating the file chains.  */
@@ -8820,9 +8819,7 @@ void
 lang_startup (const char *name)
 {
   if (first_file->filename != NULL)
-    {
-      einfo (_("%F%P: multiple STARTUP files\n"));
-    }
+    fatal (_("%P: multiple STARTUP files\n"));
   first_file->filename = name;
   first_file->local_sym_name = name;
   first_file->flags.real = true;
@@ -9049,7 +9046,7 @@ lang_record_phdrs (void)
 			break;
 		      }
 		  if (last == NULL)
-		    einfo (_("%F%P: no sections assigned to phdrs\n"));
+		    fatal (_("%P: no sections assigned to phdrs\n"));
 		}
 	      pl = last;
 	    }
@@ -9087,7 +9084,7 @@ lang_record_phdrs (void)
       if (!bfd_record_phdr (link_info.output_bfd, l->type,
 			    l->flags != NULL, flags, l->at != NULL,
 			    at, l->filehdr, l->phdrs, c, secs))
-	einfo (_("%F%P: bfd_record_phdr failed: %E\n"));
+	fatal (_("%P: bfd_record_phdr failed: %E\n"));
     }
 
   free (secs);
diff --git a/ld/ldlex.l b/ld/ldlex.l
index aa613100db0..4a75cabc299 100644
--- a/ld/ldlex.l
+++ b/ld/ldlex.l
@@ -505,9 +505,7 @@ void
 lex_push_file (FILE *file, const char *name, unsigned int sysrooted)
 {
   if (include_stack_ptr >= MAX_INCLUDE_DEPTH)
-    {
-      einfo (_("%F:includes nested too deeply\n"));
-    }
+    fatal (_("%P: includes nested too deeply\n"));
   file_name_stack[include_stack_ptr] = name;
   lineno_stack[include_stack_ptr] = lineno;
   sysrooted_stack[include_stack_ptr] = input_flags.sysrooted;
@@ -569,9 +567,7 @@ lex_redirect (const char *string, const char *fake_filename, unsigned int count)
 
   yy_init = 0;
   if (include_stack_ptr >= MAX_INCLUDE_DEPTH)
-    {
-      einfo (_("%F: macros nested too deeply\n"));
-    }
+    fatal (_("%P: macros nested too deeply\n"));
   file_name_stack[include_stack_ptr] = fake_filename;
   lineno_stack[include_stack_ptr] = lineno;
   include_stack[include_stack_ptr] = YY_CURRENT_BUFFER;
@@ -675,7 +671,7 @@ yy_input (char *buf, int max_size)
 	{
 	  result = fread (buf, 1, max_size, yyin);
 	  if (result < max_size && ferror (yyin))
-	    einfo (_("%F%P: read in flex scanner failed\n"));
+	    fatal (_("%P: read in flex scanner failed\n"));
 	}
     }
   return result;
@@ -712,7 +708,7 @@ comment (void)
 
       if (c == 0)
 	{
-	  einfo (_("%F%P: EOF in comment\n"));
+	  fatal (_("%P: EOF in comment\n"));
 	  break;
 	}
     }
@@ -733,7 +729,7 @@ lex_warn_invalid (char *where, char *what)
   if (ldfile_assumed_script)
     {
       bfd_set_error (bfd_error_file_not_recognized);
-      einfo (_("%F%s: file not recognized: %E\n"), ldlex_filename ());
+      fatal (_("%s: file not recognized: %E\n"), ldlex_filename ());
     }
 
   if (! ISPRINT (*what))
diff --git a/ld/ldmain.c b/ld/ldmain.c
index 037099b9d37..5274505b229 100644
--- a/ld/ldmain.c
+++ b/ld/ldmain.c
@@ -194,7 +194,8 @@ write_dependency_file (void)
   out = fopen (config.dependency_file, FOPEN_WT);
   if (out == NULL)
     {
-      einfo (_("%F%P: cannot open dependency file %s: %E\n"),
+      bfd_set_error (bfd_error_system_call);
+      fatal (_("%P: cannot open dependency file %s: %E\n"),
 	     config.dependency_file);
     }
 
@@ -287,7 +288,7 @@ main (int argc, char **argv)
   expandargv (&argc, &argv);
 
   if (bfd_init () != BFD_INIT_MAGIC)
-    einfo (_("%F%P: fatal error: libbfd ABI mismatch\n"));
+    fatal (_("%P: fatal error: libbfd ABI mismatch\n"));
 
   bfd_set_error_program_name (program_name);
 
@@ -490,14 +491,14 @@ main (int argc, char **argv)
     xexit (0);
 
   if (link_info.inhibit_common_definition && !bfd_link_dll (&link_info))
-    einfo (_("%F%P: --no-define-common may not be used without -shared\n"));
+    fatal (_("%P: --no-define-common may not be used without -shared\n"));
 
   if (!lang_has_input_file)
     {
       if (version_printed || command_line.print_output_format)
 	xexit (0);
       output_unknown_cmdline_warnings ();
-      einfo (_("%F%P: no input files\n"));
+      fatal (_("%P: no input files\n"));
     }
 
   if (verbose)
@@ -519,7 +520,7 @@ main (int argc, char **argv)
 	  if (config.map_file == (FILE *) NULL)
 	    {
 	      bfd_set_error (bfd_error_system_call);
-	      einfo (_("%F%P: cannot open map file %s: %E\n"),
+	      einfo (_("%P: cannot open map file %s: %E\n"),
 		     config.map_filename);
 	    }
 	}
@@ -594,7 +595,7 @@ main (int argc, char **argv)
       bfd *obfd = link_info.output_bfd;
       link_info.output_bfd = NULL;
       if (!bfd_close (obfd))
-	einfo (_("%F%P: %s: final close failed: %E\n"), output_filename);
+	fatal (_("%P: %s: final close failed: %E\n"), output_filename);
 
       /* If the --force-exe-suffix is enabled, and we're making an
 	 executable file and it doesn't end in .exe, copy it to one
@@ -621,10 +622,10 @@ main (int argc, char **argv)
 	      dst = fopen (dst_name, FOPEN_WB);
 
 	      if (!src)
-		einfo (_("%F%P: unable to open for source of copy `%s'\n"),
+		fatal (_("%P: unable to open for source of copy `%s'\n"),
 		       output_filename);
 	      if (!dst)
-		einfo (_("%F%P: unable to open for destination of copy `%s'\n"),
+		fatal (_("%P: unable to open for destination of copy `%s'\n"),
 		       dst_name);
 	      while ((l = fread (buf, 1, bsize, src)) > 0)
 		{
@@ -735,7 +736,7 @@ get_emulation (int argc, char **argv)
 		  i++;
 		}
 	      else
-		einfo (_("%F%P: missing argument to -m\n"));
+		fatal (_("%P: missing argument to -m\n"));
 	    }
 	  else if (strcmp (argv[i], "-mips1") == 0
 		   || strcmp (argv[i], "-mips2") == 0
@@ -789,11 +790,11 @@ add_ysym (const char *name)
 				  bfd_hash_newfunc,
 				  sizeof (struct bfd_hash_entry),
 				  61))
-	einfo (_("%F%P: bfd_hash_table_init failed: %E\n"));
+	fatal (_("%P: bfd_hash_table_init failed: %E\n"));
     }
 
   if (bfd_hash_lookup (link_info.notice_hash, name, true, true) == NULL)
-    einfo (_("%F%P: bfd_hash_lookup failed: %E\n"));
+    fatal (_("%P: bfd_hash_lookup failed: %E\n"));
 }
 
 void
@@ -806,11 +807,11 @@ add_ignoresym (struct bfd_link_info *info, const char *name)
 				  bfd_hash_newfunc,
 				  sizeof (struct bfd_hash_entry),
 				  61))
-	einfo (_("%F%P: bfd_hash_table_init failed: %E\n"));
+	fatal (_("%P: bfd_hash_table_init failed: %E\n"));
     }
 
   if (bfd_hash_lookup (info->ignore_hash, name, true, true) == NULL)
-    einfo (_("%F%P: bfd_hash_lookup failed: %E\n"));
+    fatal (_("%P: bfd_hash_lookup failed: %E\n"));
 }
 
 /* Record a symbol to be wrapped, from the --wrap option.  */
@@ -826,11 +827,11 @@ add_wrap (const char *name)
 				  bfd_hash_newfunc,
 				  sizeof (struct bfd_hash_entry),
 				  61))
-	einfo (_("%F%P: bfd_hash_table_init failed: %E\n"));
+	fatal (_("%P: bfd_hash_table_init failed: %E\n"));
     }
 
   if (bfd_hash_lookup (link_info.wrap_hash, name, true, true) == NULL)
-    einfo (_("%F%P: bfd_hash_lookup failed: %E\n"));
+    fatal (_("%P: bfd_hash_lookup failed: %E\n"));
 }
 
 /* Handle the -retain-symbols-file option.  */
@@ -858,7 +859,7 @@ add_keepsyms_file (const char *filename)
       xmalloc (sizeof (struct bfd_hash_table));
   if (!bfd_hash_table_init (link_info.keep_hash, bfd_hash_newfunc,
 			    sizeof (struct bfd_hash_entry)))
-    einfo (_("%F%P: bfd_hash_table_init failed: %E\n"));
+    fatal (_("%P: bfd_hash_table_init failed: %E\n"));
 
   bufsize = 100;
   buf = (char *) xmalloc (bufsize);
@@ -888,7 +889,7 @@ add_keepsyms_file (const char *filename)
 	  buf[len] = '\0';
 
 	  if (bfd_hash_lookup (link_info.keep_hash, buf, true, true) == NULL)
-	    einfo (_("%F%P: bfd_hash_lookup for insertion failed: %E\n"));
+	    fatal (_("%P: bfd_hash_lookup for insertion failed: %E\n"));
 	}
     }
 
@@ -1298,7 +1299,7 @@ constructor_callback (struct bfd_link_info *info,
   if (bfd_reloc_type_lookup (info->output_bfd, BFD_RELOC_CTOR) == NULL
       && (bfd_link_relocatable (info)
 	  || bfd_reloc_type_lookup (abfd, BFD_RELOC_CTOR) == NULL))
-    einfo (_("%F%P: BFD backend error: BFD_RELOC_CTOR unsupported\n"));
+    fatal (_("%P: BFD backend error: BFD_RELOC_CTOR unsupported\n"));
 
   s = set_name;
   if (bfd_get_symbol_leading_char (abfd) != '\0')
@@ -1310,7 +1311,7 @@ constructor_callback (struct bfd_link_info *info,
 
   h = bfd_link_hash_lookup (info->hash, set_name, true, true, true);
   if (h == (struct bfd_link_hash_entry *) NULL)
-    einfo (_("%F%P: bfd_link_hash_lookup failed: %E\n"));
+    fatal (_("%P: bfd_link_hash_lookup failed: %E\n"));
   if (h->type == bfd_link_hash_new)
     {
       h->type = bfd_link_hash_undefined;
@@ -1343,7 +1344,7 @@ symbol_warning (const char *warning, const char *symbol, bfd *abfd)
   struct warning_callback_info cinfo;
 
   if (!bfd_generic_link_read_symbols (abfd))
-    einfo (_("%F%P: %pB: could not read symbols: %E\n"), abfd);
+    fatal (_("%P: %pB: could not read symbols: %E\n"), abfd);
 
   cinfo.found = false;
   cinfo.warning = warning;
@@ -1405,14 +1406,14 @@ warning_find_reloc (bfd *abfd, asection *sec, void *iarg)
 
   relsize = bfd_get_reloc_upper_bound (abfd, sec);
   if (relsize < 0)
-    einfo (_("%F%P: %pB: could not read relocs: %E\n"), abfd);
+    fatal (_("%P: %pB: could not read relocs: %E\n"), abfd);
   if (relsize == 0)
     return;
 
   relpp = (arelent **) xmalloc (relsize);
   relcount = bfd_canonicalize_reloc (abfd, sec, relpp, info->asymbols);
   if (relcount < 0)
-    einfo (_("%F%P: %pB: could not read relocs: %E\n"), abfd);
+    fatal (_("%P: %pB: could not read relocs: %E\n"), abfd);
 
   p = relpp;
   pend = p + relcount;
diff --git a/ld/ldmisc.c b/ld/ldmisc.c
index 180b24b3448..bc6cc5ef466 100644
--- a/ld/ldmisc.c
+++ b/ld/ldmisc.c
@@ -70,7 +70,7 @@
 void
 vfinfo (FILE *fp, const char *fmt, va_list ap, bool is_warning)
 {
-  bool fatal = false;
+  bool isfatal = false;
   const char *scan;
   int arg_type;
   unsigned int arg_count = 0;
@@ -282,7 +282,7 @@ vfinfo (FILE *fp, const char *fmt, va_list ap, bool is_warning)
 
 	    case 'F':
 	      /* Error is fatal.  */
-	      fatal = true;
+	      isfatal = true;
 	      break;
 
 	    case 'P':
@@ -324,7 +324,7 @@ vfinfo (FILE *fp, const char *fmt, va_list ap, bool is_warning)
 		if (abfd != NULL)
 		  {
 		    if (!bfd_generic_link_read_symbols (abfd))
-		      einfo (_("%F%P: %pB: could not read symbols: %E\n"), abfd);
+		      fatal (_("%P: %pB: could not read symbols: %E\n"), abfd);
 
 		    asymbols = bfd_get_outsymbols (abfd);
 		  }
@@ -587,7 +587,7 @@ vfinfo (FILE *fp, const char *fmt, va_list ap, bool is_warning)
   if (is_warning && config.fatal_warnings)
     config.make_executable = false;
 
-  if (fatal)
+  if (isfatal)
     xexit (1);
 }
 
@@ -620,6 +620,21 @@ einfo (const char *fmt, ...)
   fflush (stderr);
 }
 
+/* Fatal error.  */
+
+void
+fatal (const char *fmt, ...)
+{
+  va_list arg;
+
+  fflush (stdout);
+  va_start (arg, fmt);
+  vfinfo (stderr, fmt, arg, true);
+  va_end (arg);
+  fflush (stderr);
+  xexit (1);
+}
+
 /* The buffer size for each command-line option warning.  */
 #define CMDLINE_WARNING_SIZE	256
 
@@ -698,7 +713,7 @@ output_unknown_cmdline_warnings (void)
 void
 info_assert (const char *file, unsigned int line)
 {
-  einfo (_("%F%P: internal error %s %d\n"), file, line);
+  fatal (_("%P: internal error %s %d\n"), file, line);
 }
 
 /* ('m' for map) Format info message and print on map.  */
@@ -767,6 +782,5 @@ ld_abort (const char *file, int line, const char *fn)
   else
     einfo (_("%P: internal error: aborting at %s:%d\n"),
 	   file, line);
-  einfo (_("%F%P: please report this bug\n"));
-  xexit (1);
+  fatal (_("%P: please report this bug\n"));
 }
diff --git a/ld/ldmisc.h b/ld/ldmisc.h
index 20289127c0a..35920031894 100644
--- a/ld/ldmisc.h
+++ b/ld/ldmisc.h
@@ -23,6 +23,7 @@
 
 extern void vfinfo (FILE *fp, const char *fmt, va_list arg, bool is_warning);
 extern void einfo (const char *, ...);
+extern void fatal (const char *, ...) ATTRIBUTE_NORETURN;
 extern void minfo (const char *, ...);
 extern void info_msg (const char *, ...);
 extern void lfinfo (FILE *, const char *, ...);
diff --git a/ld/ldwrite.c b/ld/ldwrite.c
index 8ce4297853b..23cf64b401e 100644
--- a/ld/ldwrite.c
+++ b/ld/ldwrite.c
@@ -57,14 +57,14 @@ build_link_order (lang_statement_union_type *statement)
 
 	link_order = bfd_new_link_order (link_info.output_bfd, output_section);
 	if (link_order == NULL)
-	  einfo (_("%F%P: bfd_new_link_order failed: %E\n"));
+	  fatal (_("%P: bfd_new_link_order failed: %E\n"));
 
 	link_order->type = bfd_data_link_order;
 	link_order->offset = statement->data_statement.output_offset;
 	link_order->u.data.contents = bfd_alloc (link_info.output_bfd,
 						 QUAD_SIZE);
 	if (link_order->u.data.contents == NULL)
-	  einfo (_("%F%P: bfd_new_link_order failed: %E\n"));
+	  fatal (_("%P: bfd_new_link_order failed: %E\n"));
 
 	value = statement->data_statement.value;
 
@@ -170,7 +170,7 @@ build_link_order (lang_statement_union_type *statement)
 
 	link_order = bfd_new_link_order (link_info.output_bfd, output_section);
 	if (link_order == NULL)
-	  einfo (_("%F%P: bfd_new_link_order failed: %E\n"));
+	  fatal (_("%P: bfd_new_link_order failed: %E\n"));
 
 	link_order->offset = rs->output_offset;
 	link_order->size = bfd_get_reloc_size (rs->howto);
@@ -178,7 +178,7 @@ build_link_order (lang_statement_union_type *statement)
 	link_order->u.reloc.p = (struct bfd_link_order_reloc *)
 	  bfd_alloc (link_info.output_bfd, sizeof (struct bfd_link_order_reloc));
 	if (link_order->u.reloc.p == NULL)
-	  einfo (_("%F%P: bfd_new_link_order failed: %E\n"));
+	  fatal (_("%P: bfd_new_link_order failed: %E\n"));
 
 	link_order->u.reloc.p->reloc = rs->reloc;
 	link_order->u.reloc.p->addend = rs->addend_value;
@@ -224,7 +224,7 @@ build_link_order (lang_statement_union_type *statement)
 	    link_order = bfd_new_link_order (link_info.output_bfd,
 					     output_section);
 	    if (link_order == NULL)
-	      einfo (_("%F%P: bfd_new_link_order failed: %E\n"));
+	      fatal (_("%P: bfd_new_link_order failed: %E\n"));
 
 	    if ((i->flags & SEC_NEVER_LOAD) != 0
 		&& (i->flags & SEC_DEBUGGING) == 0)
@@ -265,7 +265,7 @@ build_link_order (lang_statement_union_type *statement)
 	link_order = bfd_new_link_order (link_info.output_bfd,
 					 output_section);
 	if (link_order == NULL)
-	  einfo (_("%F%P: bfd_new_link_order failed: %E\n"));
+	  fatal (_("%P: bfd_new_link_order failed: %E\n"));
 	link_order->type = bfd_data_link_order;
 	link_order->size = statement->padding_statement.size;
 	link_order->offset = statement->padding_statement.output_offset;
@@ -334,8 +334,7 @@ clone_section (bfd *abfd, asection *s, const char *name, int *count)
       if (startswith (name, ".stab")
 	  || strcmp (name, "$GDB_SYMBOLS$") == 0)
 	{
-	  einfo (_ ("%F%P: cannot create split section name for %s\n"), name);
-	  /* Silence gcc warnings.  einfo exits, so we never reach here.  */
+	  fatal (_ ("%P: cannot create split section name for %s\n"), name);
 	  return NULL;
 	}
       tname[5] = 0;
@@ -346,8 +345,7 @@ clone_section (bfd *abfd, asection *s, const char *name, int *count)
       || (h = bfd_link_hash_lookup (link_info.hash,
 				    sname, true, true, false)) == NULL)
     {
-      einfo (_("%F%P: clone section failed: %E\n"));
-      /* Silence gcc warnings.  einfo exits, so we never reach here.  */
+      fatal (_("%P: clone section failed: %E\n"));
       return NULL;
     }
   free (tname);
@@ -550,8 +548,8 @@ ldwrite (void)
   if (!bfd_final_link (link_info.output_bfd, &link_info))
     {
       if (bfd_get_error () != bfd_error_no_error)
-	einfo (_("%F%P: final link failed: %E\n"));
+	fatal (_("%P: final link failed: %E\n"));
       else
-	einfo (_("%F%P: final link failed\n"));
+	fatal (_("%P: final link failed\n"));
     }
 }
diff --git a/ld/lexsup.c b/ld/lexsup.c
index 96fb73159bf..a8f0284987c 100644
--- a/ld/lexsup.c
+++ b/ld/lexsup.c
@@ -808,7 +808,8 @@ parse_args (unsigned argc, char **argv)
 	       && optc != argv[last_optind][1])
 	{
 	  if (optarg)
-	    einfo (_("%F%P: Error: unable to disambiguate: %s (did you mean -%s ?)\n"),
+	    fatal (_("%P: Error: unable to disambiguate: "
+		     "%s (did you mean -%s ?)\n"),
 		   argv[last_optind], argv[last_optind]);
 	  else
 	    einfo (_("%P: Warning: grouped short command line options are deprecated: %s\n"), argv[last_optind]);
@@ -848,7 +849,7 @@ parse_args (unsigned argc, char **argv)
 	  /* Fall through.  */
 
 	default:
-	  einfo (_("%F%P: use the --help option for usage information\n"));
+	  fatal (_("%P: use the --help option for usage information\n"));
 	  break;
 
 	case 1:			/* File name.  */
@@ -867,7 +868,7 @@ parse_args (unsigned argc, char **argv)
 		   || strcmp (optarg, "default") == 0)
 	    input_flags.dynamic = true;
 	  else
-	    einfo (_("%F%P: unrecognized -a option `%s'\n"), optarg);
+	    fatal (_("%P: unrecognized -a option `%s'\n"), optarg);
 	  break;
 	case OPTION_ASSERT:
 	  /* FIXME: We just ignore these, but we should handle them.  */
@@ -880,7 +881,7 @@ parse_args (unsigned argc, char **argv)
 	  else if (strcmp (optarg, "pure-text") == 0)
 	    ;
 	  else
-	    einfo (_("%F%P: unrecognized -assert option `%s'\n"), optarg);
+	    fatal (_("%P: unrecognized -assert option `%s'\n"), optarg);
 	  break;
 	case 'A':
 	  ldfile_add_arch (optarg);
@@ -924,8 +925,7 @@ parse_args (unsigned argc, char **argv)
 
 	      style = cplus_demangle_name_to_style (optarg);
 	      if (style == unknown_demangling)
-		einfo (_("%F%P: unknown demangling style `%s'\n"),
-		       optarg);
+		fatal (_("%P: unknown demangling style `%s'\n"), optarg);
 
 	      cplus_demangle_set_style (style);
 	    }
@@ -1032,7 +1032,7 @@ parse_args (unsigned argc, char **argv)
 	    char *end;
 	    g_switch_value = strtoul (optarg, &end, 0);
 	    if (*end)
-	      einfo (_("%F%P: invalid number `%s'\n"), optarg);
+	      fatal (_("%P: invalid number `%s'\n"), optarg);
 	  }
 	  break;
 	case 'g':
@@ -1128,7 +1128,7 @@ parse_args (unsigned argc, char **argv)
 	      link_info.unresolved_syms_in_shared_libs = RM_IGNORE;
 	    }
 	  else
-	    einfo (_("%F%P: bad --unresolved-symbols option: %s\n"), optarg);
+	    fatal (_("%P: bad --unresolved-symbols option: %s\n"), optarg);
 	  break;
 	case OPTION_WARN_UNRESOLVED_SYMBOLS:
 	  link_info.warn_unresolved_syms = true;
@@ -1215,7 +1215,7 @@ parse_args (unsigned argc, char **argv)
 	  break;
 	case OPTION_PLUGIN_OPT:
 	  if (plugin_opt_plugin_arg (optarg))
-	    einfo (_("%F%P: bad -plugin-opt option\n"));
+	    fatal (_("%P: bad -plugin-opt option\n"));
 	  break;
 	case OPTION_PLUGIN_SAVE_TEMPS:
 	  config.plugin_save_temps = true;
@@ -1235,11 +1235,11 @@ parse_args (unsigned argc, char **argv)
 	       an error message here.  We cannot just make this a warning,
 	       increment optind, and continue because getopt is too confused
 	       and will seg-fault the next time around.  */
-	    einfo(_("%F%P: unrecognised option: %s\n"), argv[optind]);
+	    fatal(_("%P: unrecognised option: %s\n"), argv[optind]);
 
 	  if (bfd_link_pic (&link_info))
-	    einfo (_("%F%P: -r and %s may not be used together\n"),
-		     bfd_link_dll (&link_info) ? "-shared" : "-pie");
+	    fatal (_("%P: -r and %s may not be used together\n"),
+		   bfd_link_dll (&link_info) ? "-shared" : "-pie");
 
 	  link_info.type = type_relocatable;
 	  config.build_constructors = false;
@@ -1348,7 +1348,7 @@ parse_args (unsigned argc, char **argv)
 	  if (config.has_shared)
 	    {
 	      if (bfd_link_relocatable (&link_info))
-		einfo (_("%F%P: -r and %s may not be used together\n"),
+		fatal (_("%P: -r and %s may not be used together\n"),
 		       "-shared");
 
 	      link_info.type = type_dll;
@@ -1360,7 +1360,7 @@ parse_args (unsigned argc, char **argv)
 		link_info.unresolved_syms_in_shared_libs = RM_IGNORE;
 	    }
 	  else
-	    einfo (_("%F%P: -shared not supported\n"));
+	    fatal (_("%P: -shared not supported\n"));
 	  break;
 	case OPTION_NO_PIE:
 	  link_info.type = type_pde;
@@ -1369,12 +1369,12 @@ parse_args (unsigned argc, char **argv)
 	  if (config.has_shared)
 	    {
 	      if (bfd_link_relocatable (&link_info))
-		einfo (_("%F%P: -r and %s may not be used together\n"), "-pie");
+		fatal (_("%P: -r and %s may not be used together\n"), "-pie");
 
 	      link_info.type = type_pie;
 	    }
 	  else
-	    einfo (_("%F%P: -pie not supported\n"));
+	    fatal (_("%P: -pie not supported\n"));
 	  break;
 	case 'h':		/* Used on Solaris.  */
 	case OPTION_SONAME:
@@ -1391,7 +1391,7 @@ parse_args (unsigned argc, char **argv)
 	  else if (strcmp (optarg, N_("ascending")) == 0)
 	    config.sort_common = sort_ascending;
 	  else
-	    einfo (_("%F%P: invalid common section sorting option: %s\n"),
+	    fatal (_("%P: invalid common section sorting option: %s\n"),
 		   optarg);
 	  break;
 	case OPTION_SORT_SECTION:
@@ -1400,8 +1400,7 @@ parse_args (unsigned argc, char **argv)
 	  else if (strcmp (optarg, N_("alignment")) == 0)
 	    sort_section = by_alignment;
 	  else
-	    einfo (_("%F%P: invalid section sorting option: %s\n"),
-		   optarg);
+	    fatal (_("%P: invalid section sorting option: %s\n"), optarg);
 	  break;
 	case OPTION_SECTION_ORDERING_FILE:
 	  if (command_line.section_ordering_file != NULL
@@ -1443,14 +1442,14 @@ parse_args (unsigned argc, char **argv)
 	    /* Check for <something>=<somthing>...  */
 	    optarg2 = strchr (optarg, '=');
 	    if (optarg2 == NULL)
-	      einfo (_("%F%P: invalid argument to option"
+	      fatal (_("%P: invalid argument to option"
 		       " \"--section-start\"\n"));
 
 	    optarg2++;
 
 	    /* So far so good.  Are all the args present?  */
 	    if ((*optarg == '\0') || (*optarg2 == '\0'))
-	      einfo (_("%F%P: missing argument(s) to option"
+	      fatal (_("%P: missing argument(s) to option"
 		       " \"--section-start\"\n"));
 
 	    /* We must copy the section name as set_section_start
@@ -1494,8 +1493,8 @@ parse_args (unsigned argc, char **argv)
 	  /* Fall through.  */
 	case OPTION_UR:
 	  if (bfd_link_pic (&link_info))
-	    einfo (_("%F%P: -r and %s may not be used together\n"),
-		     bfd_link_dll (&link_info) ? "-shared" : "-pie");
+	    fatal (_("%P: -r and %s may not be used together\n"),
+		   bfd_link_dll (&link_info) ? "-shared" : "-pie");
 
 	  link_info.type = type_relocatable;
 	  config.build_constructors = true;
@@ -1525,7 +1524,7 @@ parse_args (unsigned argc, char **argv)
 	      char *end;
 	      int level ATTRIBUTE_UNUSED = strtoul (optarg, &end, 0);
 	      if (*end)
-		einfo (_("%F%P: invalid number `%s'\n"), optarg);
+		fatal (_("%P: invalid number `%s'\n"), optarg);
 #if BFD_SUPPORTS_PLUGINS
 	      report_plugin_symbols = level > 1;
 #endif /* BFD_SUPPORTS_PLUGINS */
@@ -1720,7 +1719,7 @@ parse_args (unsigned argc, char **argv)
 	  break;
 	case ')':
 	  if (! ingroup)
-	    einfo (_("%F%P: group ended before it began (--help for usage)\n"));
+	    fatal (_("%P: group ended before it began (--help for usage)\n"));
 
 	  lang_leave_group ();
 	  ingroup--;
@@ -1736,7 +1735,7 @@ parse_args (unsigned argc, char **argv)
 
 	case OPTION_REMAP_INPUTS_FILE:
 	  if (! ldfile_add_remap_file (optarg))
-	    einfo (_("%F%P: failed to add remap file %s\n"), optarg);
+	    fatal (_("%P: failed to add remap file %s\n"), optarg);
 	  break;
 
 	case OPTION_REMAP_INPUTS:
@@ -1745,7 +1744,7 @@ parse_args (unsigned argc, char **argv)
 	    if (optarg2 == NULL)
 	      /* FIXME: Should we allow --remap-inputs=@myfile as a synonym
 		 for --remap-inputs-file=myfile ?  */
-	      einfo (_("%F%P: invalid argument to option --remap-inputs\n"));
+	      fatal (_("%P: invalid argument to option --remap-inputs\n"));
 	    size_t len = optarg2 - optarg;
 	    char * pattern = xmalloc (len + 1);
 	    memcpy (pattern, optarg, len);
@@ -1766,8 +1765,7 @@ parse_args (unsigned argc, char **argv)
 	    char *end;
 	    bfd_size_type cache_size = strtoul (optarg, &end, 0);
 	    if (*end != '\0')
-	      einfo (_("%F%P: invalid cache memory size: %s\n"),
-		     optarg);
+	      fatal (_("%P: invalid cache memory size: %s\n"), optarg);
 	    link_info.max_cache_size = cache_size;
 	  }
 	  break;
@@ -1792,7 +1790,7 @@ parse_args (unsigned argc, char **argv)
 
 	case OPTION_POP_STATE:
 	  if (input_flags.pushed == NULL)
-	    einfo (_("%F%P: no state pushed before popping\n"));
+	    fatal (_("%P: no state pushed before popping\n"));
 	  else
 	    {
 	      struct lang_input_statement_flags *oldp = input_flags.pushed;
@@ -1815,7 +1813,7 @@ parse_args (unsigned argc, char **argv)
 	  else if (strcasecmp (optarg, "discard") == 0)
 	    config.orphan_handling = orphan_handling_discard;
 	  else
-	    einfo (_("%F%P: invalid argument to option"
+	    fatal (_("%P: invalid argument to option"
 		     " \"--orphan-handling\"\n"));
 	  break;
 
@@ -1853,7 +1851,7 @@ parse_args (unsigned argc, char **argv)
 	  else if (strcmp (optarg, "share-duplicated") == 0)
 	    config.ctf_share_duplicated = true;
 	  else
-	    einfo (_("%F%P: bad --ctf-share-types option: %s\n"), optarg);
+	    fatal (_("%P: bad --ctf-share-types option: %s\n"), optarg);
 	  break;
 	}
     }
@@ -2048,7 +2046,7 @@ parse_args (unsigned argc, char **argv)
   if (config.no_section_header)
     {
       if (bfd_link_relocatable (&link_info))
-	einfo (_("%F%P: -r and -z nosectionheader may not be used together\n"));
+	fatal (_("%P: -r and -z nosectionheader may not be used together\n"));
 
       link_info.strip = strip_all;
     }
@@ -2056,9 +2054,9 @@ parse_args (unsigned argc, char **argv)
   if (!bfd_link_dll (&link_info))
     {
       if (command_line.filter_shlib)
-	einfo (_("%F%P: -F may not be used without -shared\n"));
+	fatal (_("%P: -F may not be used without -shared\n"));
       if (command_line.auxiliary_filters)
-	einfo (_("%F%P: -f may not be used without -shared\n"));
+	fatal (_("%P: -f may not be used without -shared\n"));
     }
 
   /* Treat ld -r -s as ld -r -S -x (i.e., strip all local symbols).  I
@@ -2099,7 +2097,7 @@ set_section_start (char *sect, char *valstr)
   const char *end;
   bfd_vma val = bfd_scan_vma (valstr, &end, 16);
   if (*end)
-    einfo (_("%F%P: invalid hex number `%s'\n"), valstr);
+    fatal (_("%P: invalid hex number `%s'\n"), valstr);
   lang_section_start (sect, exp_intop (val), NULL);
 }
 
@@ -2112,7 +2110,7 @@ set_segment_start (const char *section, char *valstr)
 
   bfd_vma val = bfd_scan_vma (valstr, &end, 16);
   if (*end)
-    einfo (_("%F%P: invalid hex number `%s'\n"), valstr);
+    fatal (_("%P: invalid hex number `%s'\n"), valstr);
   /* If we already have an entry for this segment, update the existing
      value.  */
   name = section + 1;
diff --git a/ld/mri.c b/ld/mri.c
index 766f3174033..7c8e59fa208 100644
--- a/ld/mri.c
+++ b/ld/mri.c
@@ -288,7 +288,7 @@ mri_format (const char *name)
     lang_add_output_format ("srec", NULL, NULL, 1);
 
   else
-    einfo (_("%F%P: unknown format type %s\n"), name);
+    fatal (_("%P: unknown format type %s\n"), name);
 }
 
 void
diff --git a/ld/pe-dll.c b/ld/pe-dll.c
index 5b274392143..a082afea03c 100644
--- a/ld/pe-dll.c
+++ b/ld/pe-dll.c
@@ -756,7 +756,7 @@ process_def_file_and_drectve (bfd *abfd ATTRIBUTE_UNUSED, struct bfd_link_info *
 
 	  if (!bfd_generic_link_read_symbols (b))
 	    {
-	      einfo (_("%F%P: %pB: could not read symbols: %E\n"), b);
+	      fatal (_("%P: %pB: could not read symbols: %E\n"), b);
 	      return;
 	    }
 
@@ -1048,7 +1048,7 @@ build_filler_bfd (bool include_edata)
 			     bfd_get_arch (link_info.output_bfd),
 			     bfd_get_mach (link_info.output_bfd)))
     {
-      einfo (_("%F%P: can not create BFD: %E\n"));
+      fatal (_("%P: can not create BFD: %E\n"));
       return;
     }
 
@@ -1326,7 +1326,7 @@ pe_walk_relocs (struct bfd_link_info *info,
 
       if (!bfd_generic_link_read_symbols (b))
 	{
-	  einfo (_("%F%P: %pB: could not read symbols: %E\n"), b);
+	  fatal (_("%P: %pB: could not read symbols: %E\n"), b);
 	  return;
 	}
 
@@ -1407,7 +1407,7 @@ pe_find_data_imports (const char *symhead,
       if (!bfd_hash_table_init (import_hash,
 				bfd_hash_newfunc,
 				sizeof (struct bfd_hash_entry)))
-	einfo (_("%F%P: bfd_hash_table_init failed: %E\n"));
+	fatal (_("%P: bfd_hash_table_init failed: %E\n"));
     }
   else
     import_hash = NULL;
@@ -1447,7 +1447,7 @@ pe_find_data_imports (const char *symhead,
 
 		if (!bfd_generic_link_read_symbols (b))
 		  {
-		    einfo (_("%F%P: %pB: could not read symbols: %E\n"), b);
+		    fatal (_("%P: %pB: could not read symbols: %E\n"), b);
 		    return;
 		  }
 
@@ -1549,7 +1549,7 @@ generate_reloc (bfd *abfd, struct bfd_link_info *info)
 
       if (!bfd_generic_link_read_symbols (b))
 	{
-	  einfo (_("%F%P: %pB: could not read symbols: %E\n"), b);
+	  fatal (_("%P: %pB: could not read symbols: %E\n"), b);
 	  return;
 	}
 
diff --git a/ld/plugin.c b/ld/plugin.c
index 2cd0279c93a..5c5189fcb26 100644
--- a/ld/plugin.c
+++ b/ld/plugin.c
@@ -252,7 +252,7 @@ plugin_opt_plugin (const char *plugin)
   newplug->name = plugin;
   newplug->dlhandle = dlopen (plugin, RTLD_NOW);
   if (!newplug->dlhandle)
-    einfo (_("%F%P: %s: error loading plugin: %s\n"), plugin, dlerror ());
+    fatal (_("%P: %s: error loading plugin: %s\n"), plugin, dlerror ());
 
   /* Check if plugin has been loaded already.  */
   while (curplug)
@@ -345,7 +345,7 @@ plugin_get_ir_dummy_bfd (const char *name, bfd *srctemplate)
 	}
     }
  report_error:
-  einfo (_("%F%P: could not create dummy IR bfd: %E\n"));
+  fatal (_("%P: could not create dummy IR bfd: %E\n"));
   return NULL;
 }
 
@@ -426,7 +426,7 @@ asymbol_from_plugin_symbol (bfd *abfd, asymbol *asym,
       unsigned char visibility;
 
       if (!elfsym)
-	einfo (_("%F%P: %s: non-ELF symbol in ELF BFD!\n"), asym->name);
+	fatal (_("%P: %s: non-ELF symbol in ELF BFD!\n"), asym->name);
 
       if (ldsym->def == LDPK_COMMON)
 	{
@@ -437,7 +437,7 @@ asymbol_from_plugin_symbol (bfd *abfd, asymbol *asym,
       switch (ldsym->visibility)
 	{
 	default:
-	  einfo (_("%F%P: unknown ELF symbol visibility: %d!\n"),
+	  fatal (_("%P: unknown ELF symbol visibility: %d!\n"),
 		 ldsym->visibility);
 	  return LDPS_ERR;
 
@@ -559,7 +559,7 @@ get_view (const void *handle, const void **viewp)
 
   /* FIXME: einfo should support %lld.  */
   if ((off_t) size != input->filesize)
-    einfo (_("%F%P: unsupported input file size: %s (%ld bytes)\n"),
+    fatal (_("%P: unsupported input file size: %s (%ld bytes)\n"),
 	   input->name, (long) input->filesize);
 
   /* Check the cached view buffer.  */
@@ -835,7 +835,7 @@ get_symbols (const void *handle, int nsyms, struct ld_plugin_symbol *syms,
 	  && blhe->type != bfd_link_hash_common)
 	{
 	  /* We should not have a new, indirect or warning symbol here.  */
-	  einfo (_("%F%P: %s: plugin symbol table corrupt (sym type %d)\n"),
+	  fatal (_("%P: %s: plugin symbol table corrupt (sym type %d)\n"),
 		 called_plugin->name, blhe->type);
 	}
 
@@ -987,13 +987,14 @@ message (int level, const char *format, ...)
     case LDPL_ERROR:
     default:
       {
-	char *newfmt = concat (level == LDPL_FATAL ? "%F" : "%X",
-			       _("%P: error: "), format, "\n",
+	char *newfmt = concat (_("%X%P: error: "), format, "\n",
 			       (const char *) NULL);
 	fflush (stdout);
 	vfinfo (stderr, newfmt, args, true);
 	fflush (stderr);
 	free (newfmt);
+	if (level == LDPL_FATAL)
+	  fatal ("");
       }
       break;
     }
@@ -1136,14 +1137,14 @@ plugin_load_plugins (void)
       if (!onloadfn)
 	onloadfn = (ld_plugin_onload) dlsym (curplug->dlhandle, "_onload");
       if (!onloadfn)
-	einfo (_("%F%P: %s: error loading plugin: %s\n"),
+	fatal (_("%P: %s: error loading plugin: %s\n"),
 	       curplug->name, dlerror ());
       set_tv_plugin_args (curplug, &my_tv[tv_header_size]);
       called_plugin = curplug;
       rv = (*onloadfn) (my_tv);
       called_plugin = NULL;
       if (rv != LDPS_OK)
-	einfo (_("%F%P: %s: plugin error: %d\n"), curplug->name, rv);
+	fatal (_("%P: %s: plugin error: %d\n"), curplug->name, rv);
       curplug = curplug->next;
     }
 
@@ -1207,7 +1208,7 @@ plugin_strdup (bfd *abfd, const char *str)
   strlength = strlen (str) + 1;
   copy = bfd_alloc (abfd, strlength);
   if (copy == NULL)
-    einfo (_("%F%P: plugin_strdup failed to allocate memory: %s\n"),
+    fatal (_("%P: plugin_strdup failed to allocate memory: %s\n"),
 	   bfd_get_error ());
   memcpy (copy, str, strlength);
   return copy;
@@ -1249,7 +1250,7 @@ plugin_object_p (bfd *ibfd, bool known_used)
 
   input = bfd_alloc (abfd, sizeof (*input));
   if (input == NULL)
-    einfo (_("%F%P: plugin failed to allocate memory for input: %s\n"),
+    fatal (_("%P: plugin failed to allocate memory for input: %s\n"),
 	   bfd_get_error ());
 
   if (!bfd_plugin_open_input (ibfd, &file))
@@ -1278,7 +1279,7 @@ plugin_object_p (bfd *ibfd, bool known_used)
 
   if (plugin_call_claim_file (&file, &claimed, &claim_file_handler_v2,
 			      known_used))
-    einfo (_("%F%P: %s: plugin reported error claiming file\n"),
+    fatal (_("%P: %s: plugin reported error claiming file\n"),
 	   plugin_error_plugin ());
 
   if (input->fd != -1
-- 
2.50.1

