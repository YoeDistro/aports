From cfea30c0084e1b57e9a7fc90d32ef1eb40c7e186 Mon Sep 17 00:00:00 2001
From: Nicola Vetrini <nicola.vetrini@bugseng.com>
Date: Thu, 10 Apr 2025 21:32:14 +0200
Subject: [PATCH 1/5] automation/eclair: Remove bespoke service B.UNEVALEFF

The Eclair runners in GitlabCI have been update.  This service is now
included, and redefining results in an error.

No functional change.

Signed-off-by: Nicola Vetrini <nicola.vetrini@bugseng.com>
Acked-by: Andrew Cooper <andrew.cooper3@citrix.com>
(cherry picked from commit a43b0a770bdcf3933634c860049e4bd65854e472)
---
 automation/eclair_analysis/ECLAIR/B.UNEVALEFF.ecl | 10 ----------
 automation/eclair_analysis/ECLAIR/analysis.ecl    |  1 -
 2 files changed, 11 deletions(-)
 delete mode 100644 automation/eclair_analysis/ECLAIR/B.UNEVALEFF.ecl

diff --git a/automation/eclair_analysis/ECLAIR/B.UNEVALEFF.ecl b/automation/eclair_analysis/ECLAIR/B.UNEVALEFF.ecl
deleted file mode 100644
index fa249b8e36..0000000000
--- a/automation/eclair_analysis/ECLAIR/B.UNEVALEFF.ecl
+++ /dev/null
@@ -1,10 +0,0 @@
--clone_service=MC3A2.R13.6,B.UNEVALEFF
-
--config=B.UNEVALEFF,summary="The operand of the `alignof' and `typeof'  operators shall not contain any expression which has potential side effects"
--config=B.UNEVALEFF,stmt_child_matcher=
-{"stmt(node(utrait_expr)&&operator(alignof))", expr, 0, "stmt(any())", {}},
-{"stmt(node(utrait_type)&&operator(alignof))", type, 0, "stmt(any())", {}},
-{"stmt(node(utrait_expr)&&operator(preferred_alignof))", expr, 0, "stmt(any())", {}},
-{"stmt(node(utrait_type)&&operator(preferred_alignof))", type, 0, "stmt(any())", {}},
-{"type(node(typeof_expr))", expr, 0, "stmt(any())", {}},
-{"type(node(typeof_type))", type, 0, "stmt(any())", {}}
diff --git a/automation/eclair_analysis/ECLAIR/analysis.ecl b/automation/eclair_analysis/ECLAIR/analysis.ecl
index 824283a989..8326156b38 100644
--- a/automation/eclair_analysis/ECLAIR/analysis.ecl
+++ b/automation/eclair_analysis/ECLAIR/analysis.ecl
@@ -52,7 +52,6 @@ their Standard Library equivalents."
 -eval_file=adopted.ecl
 -eval_file=out_of_scope.ecl
 
--eval_file=B.UNEVALEFF.ecl
 -eval_file=deviations.ecl
 -eval_file=call_properties.ecl
 -eval_file=tagging.ecl
-- 
2.50.1


From 2389f0a3b2c36737e99e942cff3da2cf33050831 Mon Sep 17 00:00:00 2001
From: Roger Pau Monne <roger.pau@citrix.com>
Date: Mon, 7 Apr 2025 13:09:38 +0200
Subject: [PATCH 2/5] tools/libxl: do not use `-c -E` compiler options together
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

It makes no sense to request for preprocessor only output and also request
object file generation.  Fix the _libxl.api-for-check target to only use
-E (preprocessor output).

Also Clang 20.0 reports an error if both options are used.

Reported-by: Andrew Cooper <andrew.cooper3@citrix.com>
Fixes: 2862bf5b6c81 ('libxl: enforce prohibitions of internal callers')
Signed-off-by: Roger Pau Monné <roger.pau@citrix.com>
Acked-by: Andrew Cooper <andrew.cooper3@citrix.com>
Acked-by: Anthony PERARD <anthony.perard@vates.tech>
(cherry picked from commit a235f856e4bbd270b085590e1f5fc9599234dcdf)
---
 tools/libs/light/Makefile | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/tools/libs/light/Makefile b/tools/libs/light/Makefile
index 37e4d16709..b690d92159 100644
--- a/tools/libs/light/Makefile
+++ b/tools/libs/light/Makefile
@@ -195,7 +195,7 @@ libxl.api-ok: check-libxl-api-rules _libxl.api-for-check
 	touch $@
 
 _libxl.api-for-check: $(XEN_INCLUDE)/libxl.h
-	$(CC) $(CPPFLAGS) $(CFLAGS) -c -E $< $(APPEND_CFLAGS) \
+	$(CC) $(CPPFLAGS) $(CFLAGS) -E $< $(APPEND_CFLAGS) \
 		-DLIBXL_EXTERNAL_CALLERS_ONLY=LIBXL_EXTERNAL_CALLERS_ONLY \
 		>$@.new
 	mv -f $@.new $@
-- 
2.50.1


From 3cc6a924d78f32b98790db274379ff5f9e946225 Mon Sep 17 00:00:00 2001
From: Andrew Cooper <andrew.cooper3@citrix.com>
Date: Fri, 13 Dec 2024 14:34:00 +0000
Subject: [PATCH 3/5] xen/lib: Introduce SHA2-256
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

A future change will need to calculate SHA2-256 digests.  Introduce an
implementation in lib/, derived from Trenchboot which itself is derived from
Linux.

In order to be useful to other architectures, it is careful with endianness
and misaligned accesses as well as being more MISRA friendly, but is only
wired up for x86 in the short term.

Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Acked-by: Roger Pau Monné <roger.pau@citrix.com>
(cherry picked from commit 372af524411f5a013bcb0b117073d8d07c026563)

Xen: CI fix from XSN-2

 * Add U suffix to the K[] table to fix MISRA Rule 7.2 violations.

Fixes: 372af524411f ("xen/lib: Introduce SHA2-256")
Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Stefano Stabellini <sstabellini@kernel.org>
(cherry picked from commit 15fe2eb5f1bac8a212c0ba3d6dfe60d1fdf851cf)
---
 xen/include/xen/sha2.h |  15 +++
 xen/lib/Makefile       |   1 +
 xen/lib/sha2-256.c     | 264 +++++++++++++++++++++++++++++++++++++++++
 3 files changed, 280 insertions(+)
 create mode 100644 xen/include/xen/sha2.h
 create mode 100644 xen/lib/sha2-256.c

diff --git a/xen/include/xen/sha2.h b/xen/include/xen/sha2.h
new file mode 100644
index 0000000000..47d97fbf01
--- /dev/null
+++ b/xen/include/xen/sha2.h
@@ -0,0 +1,15 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * SHA2-256: https://csrc.nist.gov/pubs/fips/180-2/upd1/final
+ */
+#ifndef XEN_SHA2_H
+#define XEN_SHA2_H
+
+#include <xen/types.h>
+
+#define SHA2_256_DIGEST_SIZE 32
+
+void sha2_256_digest(uint8_t digest[SHA2_256_DIGEST_SIZE],
+                     const void *msg, size_t len);
+
+#endif /* XEN_SHA2_H */
diff --git a/xen/lib/Makefile b/xen/lib/Makefile
index a485415964..03e33baaa0 100644
--- a/xen/lib/Makefile
+++ b/xen/lib/Makefile
@@ -16,6 +16,7 @@ lib-y += memset.o
 lib-y += muldiv64.o
 lib-y += parse-size.o
 lib-y += rbtree.o
+lib-$(CONFIG_X86) += sha2-256.o
 lib-y += sort.o
 lib-y += strcasecmp.o
 lib-y += strchr.o
diff --git a/xen/lib/sha2-256.c b/xen/lib/sha2-256.c
new file mode 100644
index 0000000000..19e8252188
--- /dev/null
+++ b/xen/lib/sha2-256.c
@@ -0,0 +1,264 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * SHA2-256: https://csrc.nist.gov/pubs/fips/180-2/upd1/final
+ *
+ * Originally derived from Linux.  Modified substantially to optimise for size
+ * and Xen's expected usecases.
+ */
+#include <xen/bitops.h>
+#include <xen/sha2.h>
+#include <xen/string.h>
+#include <xen/unaligned.h>
+
+struct sha2_256_state {
+    uint32_t state[SHA2_256_DIGEST_SIZE / sizeof(uint32_t)];
+    uint8_t buf[64];
+    size_t count; /* Byte count. */
+};
+
+static uint32_t choose(uint32_t x, uint32_t y, uint32_t z)
+{
+    return z ^ (x & (y ^ z));
+}
+
+static uint32_t majority(uint32_t x, uint32_t y, uint32_t z)
+{
+    return (x & y) | (z & (x | y));
+}
+
+static uint32_t e0(uint32_t x)
+{
+    return ror32(x, 2) ^ ror32(x, 13) ^ ror32(x, 22);
+}
+
+static uint32_t e1(uint32_t x)
+{
+    return ror32(x, 6) ^ ror32(x, 11) ^ ror32(x, 25);
+}
+
+static uint32_t s0(uint32_t x)
+{
+    return ror32(x, 7) ^ ror32(x, 18) ^ (x >> 3);
+}
+
+static uint32_t s1(uint32_t x)
+{
+    return ror32(x, 17) ^ ror32(x, 19) ^ (x >> 10);
+}
+
+static uint32_t blend(uint32_t W[16], unsigned int i)
+{
+#define W(i) W[(i) & 15]
+
+    return W(i) += s1(W(i - 2)) + W(i - 7) + s0(W(i - 15));
+
+#undef W
+}
+
+static const uint32_t K[] = {
+    0x428a2f98U, 0x71374491U, 0xb5c0fbcfU, 0xe9b5dba5U,
+    0x3956c25bU, 0x59f111f1U, 0x923f82a4U, 0xab1c5ed5U,
+    0xd807aa98U, 0x12835b01U, 0x243185beU, 0x550c7dc3U,
+    0x72be5d74U, 0x80deb1feU, 0x9bdc06a7U, 0xc19bf174U,
+    0xe49b69c1U, 0xefbe4786U, 0x0fc19dc6U, 0x240ca1ccU,
+    0x2de92c6fU, 0x4a7484aaU, 0x5cb0a9dcU, 0x76f988daU,
+    0x983e5152U, 0xa831c66dU, 0xb00327c8U, 0xbf597fc7U,
+    0xc6e00bf3U, 0xd5a79147U, 0x06ca6351U, 0x14292967U,
+    0x27b70a85U, 0x2e1b2138U, 0x4d2c6dfcU, 0x53380d13U,
+    0x650a7354U, 0x766a0abbU, 0x81c2c92eU, 0x92722c85U,
+    0xa2bfe8a1U, 0xa81a664bU, 0xc24b8b70U, 0xc76c51a3U,
+    0xd192e819U, 0xd6990624U, 0xf40e3585U, 0x106aa070U,
+    0x19a4c116U, 0x1e376c08U, 0x2748774cU, 0x34b0bcb5U,
+    0x391c0cb3U, 0x4ed8aa4aU, 0x5b9cca4fU, 0x682e6ff3U,
+    0x748f82eeU, 0x78a5636fU, 0x84c87814U, 0x8cc70208U,
+    0x90befffaU, 0xa4506cebU, 0xbef9a3f7U, 0xc67178f2U,
+};
+
+static void sha2_256_transform(uint32_t *state, const void *_input)
+{
+    const uint32_t *input = _input;
+    uint32_t a, b, c, d, e, f, g, h, t1, t2;
+    uint32_t W[16];
+    unsigned int i;
+
+    for ( i = 0; i < 16; i++ )
+        W[i] = get_unaligned_be32(&input[i]);
+
+    a = state[0]; b = state[1]; c = state[2]; d = state[3];
+    e = state[4]; f = state[5]; g = state[6]; h = state[7];
+
+    for ( i = 0; i < 16; i += 8 )
+    {
+        t1 = h + e1(e) + choose(e, f, g) + K[i + 0] + W[i + 0];
+        t2 = e0(a) + majority(a, b, c);    d += t1;    h = t1 + t2;
+        t1 = g + e1(d) + choose(d, e, f) + K[i + 1] + W[i + 1];
+        t2 = e0(h) + majority(h, a, b);    c += t1;    g = t1 + t2;
+        t1 = f + e1(c) + choose(c, d, e) + K[i + 2] + W[i + 2];
+        t2 = e0(g) + majority(g, h, a);    b += t1;    f = t1 + t2;
+        t1 = e + e1(b) + choose(b, c, d) + K[i + 3] + W[i + 3];
+        t2 = e0(f) + majority(f, g, h);    a += t1;    e = t1 + t2;
+        t1 = d + e1(a) + choose(a, b, c) + K[i + 4] + W[i + 4];
+        t2 = e0(e) + majority(e, f, g);    h += t1;    d = t1 + t2;
+        t1 = c + e1(h) + choose(h, a, b) + K[i + 5] + W[i + 5];
+        t2 = e0(d) + majority(d, e, f);    g += t1;    c = t1 + t2;
+        t1 = b + e1(g) + choose(g, h, a) + K[i + 6] + W[i + 6];
+        t2 = e0(c) + majority(c, d, e);    f += t1;    b = t1 + t2;
+        t1 = a + e1(f) + choose(f, g, h) + K[i + 7] + W[i + 7];
+        t2 = e0(b) + majority(b, c, d);    e += t1;    a = t1 + t2;
+    }
+
+    for ( ; i < 64; i += 8 )
+    {
+        t1 = h + e1(e) + choose(e, f, g) + K[i + 0] + blend(W, i + 0);
+        t2 = e0(a) + majority(a, b, c);    d += t1;    h = t1 + t2;
+        t1 = g + e1(d) + choose(d, e, f) + K[i + 1] + blend(W, i + 1);
+        t2 = e0(h) + majority(h, a, b);    c += t1;    g = t1 + t2;
+        t1 = f + e1(c) + choose(c, d, e) + K[i + 2] + blend(W, i + 2);
+        t2 = e0(g) + majority(g, h, a);    b += t1;    f = t1 + t2;
+        t1 = e + e1(b) + choose(b, c, d) + K[i + 3] + blend(W, i + 3);
+        t2 = e0(f) + majority(f, g, h);    a += t1;    e = t1 + t2;
+        t1 = d + e1(a) + choose(a, b, c) + K[i + 4] + blend(W, i + 4);
+        t2 = e0(e) + majority(e, f, g);    h += t1;    d = t1 + t2;
+        t1 = c + e1(h) + choose(h, a, b) + K[i + 5] + blend(W, i + 5);
+        t2 = e0(d) + majority(d, e, f);    g += t1;    c = t1 + t2;
+        t1 = b + e1(g) + choose(g, h, a) + K[i + 6] + blend(W, i + 6);
+        t2 = e0(c) + majority(c, d, e);    f += t1;    b = t1 + t2;
+        t1 = a + e1(f) + choose(f, g, h) + K[i + 7] + blend(W, i + 7);
+        t2 = e0(b) + majority(b, c, d);    e += t1;    a = t1 + t2;
+    }
+
+    state[0] += a; state[1] += b; state[2] += c; state[3] += d;
+    state[4] += e; state[5] += f; state[6] += g; state[7] += h;
+}
+
+static void sha2_256_init(struct sha2_256_state *s)
+{
+    *s = (struct sha2_256_state){
+        .state = {
+            0x6a09e667UL,
+            0xbb67ae85UL,
+            0x3c6ef372UL,
+            0xa54ff53aUL,
+            0x510e527fUL,
+            0x9b05688cUL,
+            0x1f83d9abUL,
+            0x5be0cd19UL,
+        },
+    };
+}
+
+static void sha2_256_update(struct sha2_256_state *s, const void *msg,
+                            size_t len)
+{
+    unsigned int partial = s->count & 63;
+
+    s->count += len;
+
+    if ( (partial + len) >= 64 )
+    {
+        if ( partial )
+        {
+            unsigned int rem = 64 - partial;
+
+            /* Fill the partial block. */
+            memcpy(s->buf + partial, msg, rem);
+            msg += rem;
+            len -= rem;
+
+            sha2_256_transform(s->state, s->buf);
+            partial = 0;
+        }
+
+        for ( ; len >= 64; msg += 64, len -= 64 )
+            sha2_256_transform(s->state, msg);
+    }
+
+    /* Remaining data becomes partial. */
+    memcpy(s->buf + partial, msg, len);
+}
+
+static void sha2_256_final(struct sha2_256_state *s, void *_dst)
+{
+    uint32_t *dst = _dst;
+    unsigned int i, partial = s->count & 63;
+
+    /* Start padding */
+    s->buf[partial++] = 0x80;
+
+    if ( partial > 56 )
+    {
+        /* Need one extra block - pad to 64 */
+        memset(s->buf + partial, 0, 64 - partial);
+        sha2_256_transform(s->state, s->buf);
+        partial = 0;
+    }
+    /* Pad to 56 */
+    memset(s->buf + partial, 0, 56 - partial);
+
+    /* Append the bit count */
+    put_unaligned_be64((uint64_t)s->count << 3, &s->buf[56]);
+    sha2_256_transform(s->state, s->buf);
+
+    /* Store state in digest */
+    for ( i = 0; i < 8; i++ )
+        put_unaligned_be32(s->state[i], &dst[i]);
+}
+
+void sha2_256_digest(uint8_t digest[SHA2_256_DIGEST_SIZE],
+                     const void *msg, size_t len)
+{
+    struct sha2_256_state s;
+
+    sha2_256_init(&s);
+    sha2_256_update(&s, msg, len);
+    sha2_256_final(&s, digest);
+}
+
+#ifdef CONFIG_SELF_TESTS
+
+#include <xen/init.h>
+#include <xen/lib.h>
+
+static const struct test {
+    const char *msg;
+    uint8_t digest[SHA2_256_DIGEST_SIZE];
+} tests[] __initconst = {
+    {
+        .msg = "abc",
+        .digest = {
+            0xba, 0x78, 0x16, 0xbf, 0x8f, 0x01, 0xcf, 0xea,
+            0x41, 0x41, 0x40, 0xde, 0x5d, 0xae, 0x22, 0x23,
+            0xb0, 0x03, 0x61, 0xa3, 0x96, 0x17, 0x7a, 0x9c,
+            0xb4, 0x10, 0xff, 0x61, 0xf2, 0x00, 0x15, 0xad,
+        },
+    },
+    {
+        .msg = "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq",
+        .digest = {
+            0x24, 0x8d, 0x6a, 0x61, 0xd2, 0x06, 0x38, 0xb8,
+            0xe5, 0xc0, 0x26, 0x93, 0x0c, 0x3e, 0x60, 0x39,
+            0xa3, 0x3c, 0xe4, 0x59, 0x64, 0xff, 0x21, 0x67,
+            0xf6, 0xec, 0xed, 0xd4, 0x19, 0xdb, 0x06, 0xc1,
+        },
+    },
+};
+
+static void __init __constructor test_sha2_256(void)
+{
+    for ( unsigned int i = 0; i < ARRAY_SIZE(tests); ++i )
+    {
+        const struct test *t = &tests[i];
+        uint8_t res[SHA2_256_DIGEST_SIZE] = {};
+
+        sha2_256_digest(res, t->msg, strlen(t->msg));
+
+        if ( memcmp(res, t->digest, sizeof(t->digest)) == 0 )
+            continue;
+
+        panic("%s() msg '%s' failed\n"
+              "  expected %" STR(SHA2_256_DIGEST_SIZE) "phN\n"
+              "       got %" STR(SHA2_256_DIGEST_SIZE) "phN\n",
+              __func__, t->msg, t->digest, res);
+    }
+}
+#endif /* CONFIG_SELF_TESTS */
-- 
2.50.1


From 56d85952addb47f7341ad5d5d67aab002c7e7118 Mon Sep 17 00:00:00 2001
From: Andrew Cooper <andrew.cooper3@citrix.com>
Date: Fri, 13 Dec 2024 14:34:00 +0000
Subject: [PATCH 4/5] x86/ucode: Perform extra SHA2 checks on AMD Fam17h/19h
 microcode
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Collisions have been found in the microcode signing algorithm used by AMD
Fam17h/19h CPUs, and now anyone can sign their own.

For more details, see:
  https://bughunters.google.com/blog/5424842357473280/zen-and-the-art-of-microcode-hacking
  https://www.amd.com/en/resources/product-security/bulletin/amd-sb-7033.html

As a stopgap mitigation, check the digest of patches against a table of blobs
with known provenance.  These are all Fam17h and Fam19h blobs included in
linux-firwmare at the time of writing, specifically:

  https://git.kernel.org/firmware/linux-firmware/c/48bb90cceb882cab8e9ab692bc5779d3bf3a13b8

This checks can be opted out of by booting with ucode=no-digest-check, but
doing so is not recommended.

Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Acked-by: Roger Pau Monné <roger.pau@citrix.com>
(cherry picked from commit 630e8875ab368b97cc7231aaf3809e3d7d5687e1)

Xen: CI fix from XSN-2

 * Add cf_check annotation to cmp_patch_id() used by bsearch().

Fixes: 630e8875ab36 ("x86/ucode: Perform extra SHA2 checks on AMD Fam17h/19h microcode")
Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Stefano Stabellini <sstabellini@kernel.org>
(cherry picked from commit 15fe2eb5f1bac8a212c0ba3d6dfe60d1fdf851cf)
---
 docs/misc/xen-command-line.pandoc             |  10 +-
 .../x86/cpu/microcode/amd-patch-digests.c     | 226 ++++++++++++++++++
 xen/arch/x86/cpu/microcode/amd.c              |  66 ++++-
 xen/arch/x86/cpu/microcode/core.c             |   3 +
 xen/arch/x86/cpu/microcode/private.h          |   2 +
 5 files changed, 304 insertions(+), 3 deletions(-)
 create mode 100644 xen/arch/x86/cpu/microcode/amd-patch-digests.c

diff --git a/docs/misc/xen-command-line.pandoc b/docs/misc/xen-command-line.pandoc
index ff10ff9f65..559fb21c5b 100644
--- a/docs/misc/xen-command-line.pandoc
+++ b/docs/misc/xen-command-line.pandoc
@@ -2671,10 +2671,10 @@ performance.
    Alternatively, selecting `tsx=1` will re-enable TSX at the users own risk.
 
 ### ucode
-> `= List of [ <integer> | scan=<bool>, nmi=<bool>, allow-same=<bool> ]`
+> `= List of [ <integer> | scan=<bool>, nmi=<bool>, allow-same=<bool>, digest-check=<bool> ]`
 
     Applicability: x86
-    Default: `nmi`
+    Default: `nmi,digest-check`
 
 Controls for CPU microcode loading. For early loading, this parameter can
 specify how and where to find the microcode update blob. For late loading,
@@ -2708,6 +2708,12 @@ trying to reload the same version.  Many CPUs will actually reload microcode
 of the same version, and this allows for easy testing of the late microcode
 loading path.
 
+The `digest-check=` option is active by default and controls whether to
+perform additional authenticity checks.  Collisions in the signature algorithm
+used by AMD Fam17h/19h processors have been found.  Xen contains a table of
+digests of microcode patches with known-good provenance, and will block
+loading of patches that do not match.
+
 ### unrestricted_guest (Intel)
 > `= <boolean>`
 
diff --git a/xen/arch/x86/cpu/microcode/amd-patch-digests.c b/xen/arch/x86/cpu/microcode/amd-patch-digests.c
new file mode 100644
index 0000000000..d327612267
--- /dev/null
+++ b/xen/arch/x86/cpu/microcode/amd-patch-digests.c
@@ -0,0 +1,226 @@
+/* Generated from linux-firmware. */
+{
+    .patch_id = 0x0800126f,
+    .digest = {
+        0x2b, 0x5a, 0xf2, 0x9c, 0xdd, 0xd2, 0x7f, 0xec,
+        0xec, 0x96, 0x09, 0x57, 0xb0, 0x96, 0x29, 0x8b,
+        0x2e, 0x26, 0x91, 0xf0, 0x49, 0x33, 0x42, 0x18,
+        0xdd, 0x4b, 0x65, 0x5a, 0xd4, 0x15, 0x3d, 0x33,
+    },
+},
+{
+    .patch_id = 0x0800820d,
+    .digest = {
+        0x68, 0x98, 0x83, 0xcd, 0x22, 0x0d, 0xdd, 0x59,
+        0x73, 0x2c, 0x5b, 0x37, 0x1f, 0x84, 0x0e, 0x67,
+        0x96, 0x43, 0x83, 0x0c, 0x46, 0x44, 0xab, 0x7c,
+        0x7b, 0x65, 0x9e, 0x57, 0xb5, 0x90, 0x4b, 0x0e,
+    },
+},
+{
+    .patch_id = 0x0830107c,
+    .digest = {
+        0x21, 0x64, 0xde, 0xfb, 0x9f, 0x68, 0x96, 0x47,
+        0x70, 0x5c, 0xe2, 0x8f, 0x18, 0x52, 0x6a, 0xac,
+        0xa4, 0xd2, 0x2e, 0xe0, 0xde, 0x68, 0x66, 0xc3,
+        0xeb, 0x1e, 0xd3, 0x3f, 0xbc, 0x51, 0x1d, 0x38,
+    },
+},
+{
+    .patch_id = 0x0860010d,
+    .digest = {
+        0x86, 0xb6, 0x15, 0x83, 0xbc, 0x3b, 0x9c, 0xe0,
+        0xb3, 0xef, 0x1d, 0x99, 0x84, 0x35, 0x15, 0xf7,
+        0x7c, 0x2a, 0xc6, 0x42, 0xdb, 0x73, 0x07, 0x5c,
+        0x7d, 0xc3, 0x02, 0xb5, 0x43, 0x06, 0x5e, 0xf8,
+    },
+},
+{
+    .patch_id = 0x08608108,
+    .digest = {
+        0x14, 0xfe, 0x57, 0x86, 0x49, 0xc8, 0x68, 0xe2,
+        0x11, 0xa3, 0xcb, 0x6e, 0xff, 0x6e, 0xd5, 0x38,
+        0xfe, 0x89, 0x1a, 0xe0, 0x67, 0xbf, 0xc4, 0xcc,
+        0x1b, 0x9f, 0x84, 0x77, 0x2b, 0x9f, 0xaa, 0xbd,
+    },
+},
+{
+    .patch_id = 0x08701034,
+    .digest = {
+        0xc3, 0x14, 0x09, 0xa8, 0x9c, 0x3f, 0x8d, 0x83,
+        0x9b, 0x4c, 0xa5, 0xb7, 0x64, 0x8b, 0x91, 0x5d,
+        0x85, 0x6a, 0x39, 0x26, 0x1e, 0x14, 0x41, 0xa8,
+        0x75, 0xea, 0xa6, 0xf9, 0xc9, 0xd1, 0xea, 0x2b,
+    },
+},
+{
+    .patch_id = 0x08a0000a,
+    .digest = {
+        0x73, 0x31, 0x26, 0x22, 0xd4, 0xf9, 0xee, 0x3c,
+        0x07, 0x06, 0xe7, 0xb9, 0xad, 0xd8, 0x72, 0x44,
+        0x33, 0x31, 0xaa, 0x7d, 0xc3, 0x67, 0x0e, 0xdb,
+        0x47, 0xb5, 0xaa, 0xbc, 0xf5, 0xbb, 0xd9, 0x20,
+    },
+},
+{
+    .patch_id = 0x0a00107a,
+    .digest = {
+        0x5f, 0x92, 0xca, 0xff, 0xc3, 0x59, 0x22, 0x5f,
+        0x02, 0xa0, 0x91, 0x3b, 0x4a, 0x45, 0x10, 0xfd,
+        0x19, 0xe1, 0x8a, 0x6d, 0x9a, 0x92, 0xc1, 0x3f,
+        0x75, 0x78, 0xac, 0x78, 0x03, 0x1d, 0xdb, 0x18,
+    },
+},
+{
+    .patch_id = 0x0a0011d5,
+    .digest = {
+        0xed, 0x69, 0x89, 0xf4, 0xeb, 0x64, 0xc2, 0x13,
+        0xe0, 0x51, 0x1f, 0x03, 0x26, 0x52, 0x7d, 0xb7,
+        0x93, 0x5d, 0x65, 0xca, 0xb8, 0x12, 0x1d, 0x62,
+        0x0d, 0x5b, 0x65, 0x34, 0x69, 0xb2, 0x62, 0x21,
+    },
+},
+{
+    .patch_id = 0x0a001238,
+    .digest = {
+        0x72, 0xf7, 0x4b, 0x0c, 0x7d, 0x58, 0x65, 0xcc,
+        0x00, 0xcc, 0x57, 0x16, 0x68, 0x16, 0xf8, 0x2a,
+        0x1b, 0xb3, 0x8b, 0xe1, 0xb6, 0x83, 0x8c, 0x7e,
+        0xc0, 0xcd, 0x33, 0xf2, 0x8d, 0xf9, 0xef, 0x59,
+    },
+},
+{
+    .patch_id = 0x0a00820c,
+    .digest = {
+        0xa8, 0x0c, 0x81, 0xc0, 0xa6, 0x00, 0xe7, 0xf3,
+        0x5f, 0x65, 0xd3, 0xb9, 0x6f, 0xea, 0x93, 0x63,
+        0xf1, 0x8c, 0x88, 0x45, 0xd7, 0x82, 0x80, 0xd1,
+        0xe1, 0x3b, 0x8d, 0xb2, 0xf8, 0x22, 0x03, 0xe2,
+    },
+},
+{
+    .patch_id = 0x0a101148,
+    .digest = {
+        0x20, 0xd5, 0x6f, 0x40, 0x4a, 0xf6, 0x48, 0x90,
+        0xc2, 0x93, 0x9a, 0xc2, 0xfd, 0xac, 0xef, 0x4f,
+        0xfa, 0xc0, 0x3d, 0x92, 0x3c, 0x6d, 0x01, 0x08,
+        0xf1, 0x5e, 0xb0, 0xde, 0xb4, 0x98, 0xae, 0xc4,
+    },
+},
+{
+    .patch_id = 0x0a101248,
+    .digest = {
+        0xed, 0x3b, 0x95, 0xa6, 0x68, 0xa7, 0x77, 0x3e,
+        0xfc, 0x17, 0x26, 0xe2, 0x7b, 0xd5, 0x56, 0x22,
+        0x2c, 0x1d, 0xef, 0xeb, 0x56, 0xdd, 0xba, 0x6e,
+        0x1b, 0x7d, 0x64, 0x9d, 0x4b, 0x53, 0x13, 0x75,
+    },
+},
+{
+    .patch_id = 0x0a108108,
+    .digest = {
+        0xed, 0xc2, 0xec, 0xa1, 0x15, 0xc6, 0x65, 0xe9,
+        0xd0, 0xef, 0x39, 0xaa, 0x7f, 0x55, 0x06, 0xc6,
+        0xf5, 0xd4, 0x3f, 0x7b, 0x14, 0xd5, 0x60, 0x2c,
+        0x28, 0x1e, 0x9c, 0x59, 0x69, 0x99, 0x4d, 0x16,
+    },
+},
+{
+    .patch_id = 0x0a20102d,
+    .digest = {
+        0xf9, 0x6e, 0xf2, 0x32, 0xd3, 0x0f, 0x5f, 0x11,
+        0x59, 0xa1, 0xfe, 0xcc, 0xcd, 0x9b, 0x42, 0x89,
+        0x8b, 0x89, 0x2f, 0xb5, 0xbb, 0x82, 0xef, 0x23,
+        0x8c, 0xe9, 0x19, 0x3e, 0xcc, 0x3f, 0x7b, 0xb4,
+    },
+},
+{
+    .patch_id = 0x0a201210,
+    .digest = {
+        0xe8, 0x6d, 0x51, 0x6a, 0x8e, 0x72, 0xf3, 0xfe,
+        0x6e, 0x16, 0xbc, 0x62, 0x59, 0x40, 0x17, 0xe9,
+        0x6d, 0x3d, 0x0e, 0x6b, 0xa7, 0xac, 0xe3, 0x68,
+        0xf7, 0x55, 0xf0, 0x13, 0xbb, 0x22, 0xf6, 0x41,
+    },
+},
+{
+    .patch_id = 0x0a404107,
+    .digest = {
+        0xbb, 0x04, 0x4e, 0x47, 0xdd, 0x5e, 0x26, 0x45,
+        0x1a, 0xc9, 0x56, 0x24, 0xa4, 0x4c, 0x82, 0xb0,
+        0x8b, 0x0d, 0x9f, 0xf9, 0x3a, 0xdf, 0xc6, 0x81,
+        0x13, 0xbc, 0xc5, 0x25, 0xe4, 0xc5, 0xc3, 0x99,
+    },
+},
+{
+    .patch_id = 0x0a500011,
+    .digest = {
+        0x23, 0x3d, 0x70, 0x7d, 0x03, 0xc3, 0xc4, 0xf4,
+        0x2b, 0x82, 0xc6, 0x05, 0xda, 0x80, 0x0a, 0xf1,
+        0xd7, 0x5b, 0x65, 0x3a, 0x7d, 0xab, 0xdf, 0xa2,
+        0x11, 0x5e, 0x96, 0x7e, 0x71, 0xe9, 0xfc, 0x74,
+    },
+},
+{
+    .patch_id = 0x0a601209,
+    .digest = {
+        0x66, 0x48, 0xd4, 0x09, 0x05, 0xcb, 0x29, 0x32,
+        0x66, 0xb7, 0x9a, 0x76, 0xcd, 0x11, 0xf3, 0x30,
+        0x15, 0x86, 0xcc, 0x5d, 0x97, 0x0f, 0xc0, 0x46,
+        0xe8, 0x73, 0xe2, 0xd6, 0xdb, 0xd2, 0x77, 0x1d,
+    },
+},
+{
+    .patch_id = 0x0a704107,
+    .digest = {
+        0xf3, 0xc6, 0x58, 0x26, 0xee, 0xac, 0x3f, 0xd6,
+        0xce, 0xa1, 0x72, 0x47, 0x3b, 0xba, 0x2b, 0x93,
+        0x2a, 0xad, 0x8e, 0x6b, 0xea, 0x9b, 0xb7, 0xc2,
+        0x64, 0x39, 0x71, 0x8c, 0xce, 0xe7, 0x41, 0x39,
+    },
+},
+{
+    .patch_id = 0x0a705206,
+    .digest = {
+        0x8d, 0xc0, 0x76, 0xbd, 0x58, 0x9f, 0x8f, 0xa4,
+        0x12, 0x9d, 0x21, 0xfb, 0x48, 0x21, 0xbc, 0xe7,
+        0x67, 0x6f, 0x04, 0x18, 0xae, 0x20, 0x87, 0x4b,
+        0x03, 0x35, 0xe9, 0xbe, 0xfb, 0x06, 0xdf, 0xfc,
+    },
+},
+{
+    .patch_id = 0x0a708007,
+    .digest = {
+        0x6b, 0x76, 0xcc, 0x78, 0xc5, 0x8a, 0xa3, 0xe3,
+        0x32, 0x2d, 0x79, 0xe4, 0xc3, 0x80, 0xdb, 0xb2,
+        0x07, 0xaa, 0x3a, 0xe0, 0x57, 0x13, 0x72, 0x80,
+        0xdf, 0x92, 0x73, 0x84, 0x87, 0x3c, 0x73, 0x93,
+    },
+},
+{
+    .patch_id = 0x0a70c005,
+    .digest = {
+        0x88, 0x5d, 0xfb, 0x79, 0x64, 0xd8, 0x46, 0x3b,
+        0x4a, 0x83, 0x8e, 0x77, 0x7e, 0xcf, 0xb3, 0x0f,
+        0x1f, 0x1f, 0xf1, 0x97, 0xeb, 0xfe, 0x56, 0x55,
+        0xee, 0x49, 0xac, 0xe1, 0x8b, 0x13, 0xc5, 0x13,
+    },
+},
+{
+    .patch_id = 0x0aa00116,
+    .digest = {
+        0xe8, 0x4c, 0x2c, 0x88, 0xa1, 0xac, 0x24, 0x63,
+        0x65, 0xe5, 0xaa, 0x2d, 0x16, 0xa9, 0xc3, 0xf5,
+        0xfe, 0x1d, 0x5e, 0x65, 0xc7, 0xaa, 0x92, 0x4d,
+        0x91, 0xee, 0x76, 0xbb, 0x4c, 0x66, 0x78, 0xc9,
+    },
+},
+{
+    .patch_id = 0x0aa00215,
+    .digest = {
+        0x55, 0xd3, 0x28, 0xcb, 0x87, 0xa9, 0x32, 0xe9,
+        0x4e, 0x85, 0x4b, 0x7c, 0x6b, 0xd5, 0x7c, 0xd4,
+        0x1b, 0x51, 0x71, 0x3a, 0x0e, 0x0b, 0xdc, 0x9b,
+        0x68, 0x2f, 0x46, 0xee, 0xfe, 0xc6, 0x6d, 0xef,
+    },
+},
diff --git a/xen/arch/x86/cpu/microcode/amd.c b/xen/arch/x86/cpu/microcode/amd.c
index 31fbd326e5..e17c60fe3b 100644
--- a/xen/arch/x86/cpu/microcode/amd.c
+++ b/xen/arch/x86/cpu/microcode/amd.c
@@ -16,7 +16,9 @@
 
 #include <xen/err.h>
 #include <xen/init.h>
+#include <xen/lib.h>
 #include <xen/mm.h> /* TODO: Fix asm/tlbflush.h breakage */
+#include <xen/sha2.h>
 
 #include <asm/msr.h>
 
@@ -91,6 +93,59 @@ static struct {
     uint16_t id;
 } equiv __read_mostly;
 
+static const struct patch_digest {
+    uint32_t patch_id;
+    uint8_t digest[SHA2_256_DIGEST_SIZE];
+} patch_digests[] = {
+#include "amd-patch-digests.c"
+};
+
+static int cf_check cmp_patch_id(const void *key, const void *elem)
+{
+    const struct patch_digest *pd = elem;
+    uint32_t patch_id = *(uint32_t *)key;
+
+    if ( patch_id == pd->patch_id )
+        return 0;
+    else if ( patch_id < pd->patch_id )
+        return -1;
+    return 1;
+}
+
+static bool check_digest(const struct container_microcode *mc)
+{
+    const struct microcode_patch *patch = mc->patch;
+    const struct patch_digest *pd;
+    uint8_t digest[SHA2_256_DIGEST_SIZE];
+
+    /* Only Fam17h/19h are known to need extra checks.  Skip other families. */
+    if ( boot_cpu_data.x86 < 0x17 || boot_cpu_data.x86 > 0x19 ||
+         !opt_digest_check )
+        return true;
+
+    pd = bsearch(&patch->patch_id, patch_digests, ARRAY_SIZE(patch_digests),
+                 sizeof(struct patch_digest), cmp_patch_id);
+    if ( !pd )
+    {
+        printk(XENLOG_WARNING "No digest found for patch_id %08x\n",
+               patch->patch_id);
+        return false;
+    }
+
+    sha2_256_digest(digest, patch, mc->len);
+
+    if ( memcmp(digest, pd->digest, sizeof(digest)) )
+    {
+        printk(XENLOG_WARNING "Patch %08x SHA256 mismatch:\n"
+               "  expected %" STR(SHA2_256_DIGEST_SIZE) "phN\n"
+               "       got %" STR(SHA2_256_DIGEST_SIZE) "phN\n",
+               patch->patch_id, pd->digest, digest);
+        return false;
+    }
+
+    return true;
+}
+
 static void cf_check collect_cpu_info(void)
 {
     struct cpu_signature *csig = &this_cpu(cpu_sig);
@@ -394,7 +449,8 @@ static struct microcode_patch *cf_check cpu_request_microcode(
              * one with higher revision.
              */
             if ( (microcode_fits(mc->patch) != MIS_UCODE) &&
-                 (!saved || (compare_header(mc->patch, saved) == NEW_UCODE)) )
+                 (!saved || (compare_header(mc->patch, saved) == NEW_UCODE)) &&
+                 check_digest(mc) )
             {
                 saved = mc->patch;
                 saved_size = mc->len;
@@ -449,6 +505,14 @@ static const struct microcode_ops __initconst_cf_clobber amd_ucode_ops = {
 
 void __init ucode_probe_amd(struct microcode_ops *ops)
 {
+    if ( !opt_digest_check &&
+         boot_cpu_data.x86 >= 0x17 && boot_cpu_data.x86 <= 0x19 )
+    {
+        printk(XENLOG_WARNING
+               "Microcode patch additional digest checks disabled");
+        add_taint(TAINT_CPU_OUT_OF_SPEC);
+    }
+
     if ( boot_cpu_data.x86 < 0x10 )
         return;
 
diff --git a/xen/arch/x86/cpu/microcode/core.c b/xen/arch/x86/cpu/microcode/core.c
index 655bc41e07..cae3d1ee3d 100644
--- a/xen/arch/x86/cpu/microcode/core.c
+++ b/xen/arch/x86/cpu/microcode/core.c
@@ -99,6 +99,7 @@ static bool __initdata ucode_scan;
 static bool ucode_in_nmi = true;
 
 bool __read_mostly opt_ucode_allow_same;
+bool __ro_after_init opt_digest_check = true;
 
 /* Protected by microcode_mutex */
 static struct microcode_patch *microcode_cache;
@@ -128,6 +129,8 @@ static int __init cf_check parse_ucode(const char *s)
             ucode_in_nmi = val;
         else if ( (val = parse_boolean("allow-same", s, ss)) >= 0 )
             opt_ucode_allow_same = val;
+        else if ( (val = parse_boolean("digest-check", s, ss)) >= 0 )
+            opt_digest_check = val;
         else if ( !ucode_mod_forced ) /* Not forced by EFI */
         {
             if ( (val = parse_boolean("scan", s, ss)) >= 0 )
diff --git a/xen/arch/x86/cpu/microcode/private.h b/xen/arch/x86/cpu/microcode/private.h
index da556fe506..ef134724d8 100644
--- a/xen/arch/x86/cpu/microcode/private.h
+++ b/xen/arch/x86/cpu/microcode/private.h
@@ -60,6 +60,8 @@ struct microcode_ops {
         const struct microcode_patch *new, const struct microcode_patch *old);
 };
 
+extern bool opt_digest_check;
+
 /*
  * Microcode loading falls into one of 3 states.
  *   - No support at all
-- 
2.50.1


From 465ccf84e382d367833924cc9fb44eb1580f2337 Mon Sep 17 00:00:00 2001
From: Andrew Cooper <andrew.cooper3@citrix.com>
Date: Tue, 8 Apr 2025 17:09:15 +0100
Subject: [PATCH 5/5] x86/ucode: Extend AMD digest checks to cover Zen5 CPUs
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

AMD have updated the SB-7033 advisory to include Zen5 CPUs.  Extend the digest
check to cover Zen5 too.

In practice, cover everything until further notice.

Observant readers may be wondering where the update to the digest list is.  At
the time of writing, no Zen5 patches are available via a verifiable channel.

Link: https://www.amd.com/en/resources/product-security/bulletin/amd-sb-7033.html
Fixes: 630e8875ab36 ("x86/ucode: Perform extra SHA2 checks on AMD Fam17h/19h microcode")
Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Roger Pau Monné <roger.pau@citrix.com>
(cherry picked from commit b63951467e964bcc927f823fc943e40069fac0c9)

x86/ucode: Extend warning about disabling digest check too

This was missed by accident.

Fixes: b63951467e96 ("x86/ucode: Extend AMD digest checks to cover Zen5 CPUs")
Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Roger Pau Monné <roger.pau@citrix.com>
(cherry picked from commit 59bb316ea89e7f9461690fe00547d7d2af96321d)
---
 xen/arch/x86/cpu/microcode/amd.c | 11 +++++++----
 1 file changed, 7 insertions(+), 4 deletions(-)

diff --git a/xen/arch/x86/cpu/microcode/amd.c b/xen/arch/x86/cpu/microcode/amd.c
index e17c60fe3b..4f236e4399 100644
--- a/xen/arch/x86/cpu/microcode/amd.c
+++ b/xen/arch/x86/cpu/microcode/amd.c
@@ -118,8 +118,12 @@ static bool check_digest(const struct container_microcode *mc)
     const struct patch_digest *pd;
     uint8_t digest[SHA2_256_DIGEST_SIZE];
 
-    /* Only Fam17h/19h are known to need extra checks.  Skip other families. */
-    if ( boot_cpu_data.x86 < 0x17 || boot_cpu_data.x86 > 0x19 ||
+    /*
+     * Zen1 thru Zen5 CPUs are known to use a weak signature algorithm on
+     * microcode updates.  Mitigate by checking the digest of the patch
+     * against a list of known provenance.
+     */
+    if ( boot_cpu_data.x86 < 0x17 ||
          !opt_digest_check )
         return true;
 
@@ -505,8 +509,7 @@ static const struct microcode_ops __initconst_cf_clobber amd_ucode_ops = {
 
 void __init ucode_probe_amd(struct microcode_ops *ops)
 {
-    if ( !opt_digest_check &&
-         boot_cpu_data.x86 >= 0x17 && boot_cpu_data.x86 <= 0x19 )
+    if ( !opt_digest_check && boot_cpu_data.x86 >= 0x17 )
     {
         printk(XENLOG_WARNING
                "Microcode patch additional digest checks disabled");
-- 
2.50.1

